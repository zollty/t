---
layout: post
publishTime: 2018-05-01
category: 网络
tags: ARP
---

<div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#c5kcdy').fadeToggle(100);"><p><strong>题干=</strong></p><p>什么是ARP欺骗？</p></div><div id="c5kcdy" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>首先要明白什么是ARP协议，即<span style="color: rgb(192, 0, 0);">ARP（Address Resolution Protocol）</span>，地址解析协议，是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。相关协议有RARP、代理ARP。NDP用于在IPv6中代替地址解析协议。</p><p style='line-height: 1;'><br/></p><p>ARP欺骗可以分为双向欺骗和单向欺骗。</p><p><strong>&nbsp; 单向欺骗</strong>：</p><p>假设分别有三个机器 &nbsp;A(网关) B(server) C(server) ，A要跟C正常通讯。主机A发起寻找C的ARP请求，局域网内的主机B伪装成C，向A发送一个自己伪造的ARP应答，当A接收到B伪造的ARP应答，就会更新本地的ARP缓存（网关A被欺骗了），这时B就伪装成C了。</p><p><strong>&nbsp; 双向欺骗</strong>：</p><p>主机A要跟C正常通讯，B冒充一个中间人，B向A说我是才C，向C说我才是A。也就是说，A寻找C时，B应答了并伪装成C，C寻找A时，B也应答了并伪装成A，那么这样的情况下A和C的ARP缓存表互相都指向了B。以后通讯过程就是 A把数据发送给B，B再发送给C。然后C把数据发送B，B再把数据给A。</p><p style='line-height: 1;'><br/></p><p>ARP欺骗技术在路由器上的应用：</p><p>这是我们每天都经历的ARP欺骗，早上开路由器开PC，我们上Google，PC在发送IP包之前（假设Google的IP为173.194.72.94，当然事先要先通过DNS服务器获取Google的IP，这个不多谈）要先把这个IP包装配为以太网帧，所以PC必须要知道Google服务器端MAC，才能填充好以太网帧。要想知道Google的MAC地址，我们的PC就要发送ARP广播请求，跟你一个局域网里的所有以太网设备都能收到这个请求，你希望有人告诉自己与173.194.72.94匹配的MAC地址是多少，因为我们的PC跟Google的服务器不在一个局域网里，所以Google服务器没法收到你的ARP请求，但是如果这个局域网中有其他PC知道的话，它收到这个请求就会给你发送ARP应答告诉你，如果没人知道怎么办？只能靠骗了！这个骗子就是路由器，这也是它的一个职责。路由器用自己的MAC地址冒充Google服务器的MAC地址，给你发ARP应答糊弄你，你收到应答后喜得不行，然后把所有帧都发给了路由器。</p><p>路由器上的ARP欺骗其实是一个双向欺骗，路由器充当了网络数据传输的一个中间人。</p><p>参考资料：</p><p><a href="http://netsecurity.51cto.com/art/201304/387383.htm">http://netsecurity.51cto.com/art/201304/387383.htm</a></p><p><a href="http://netsecurity.51cto.com/art/201212/371494.htm">http://netsecurity.51cto.com/art/201212/371494.htm</a></p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#vx2ax3').fadeToggle(100);"><p><strong>题干=</strong></p><p>内网和外网IP是怎么映射的，TCP请求怎么通过一个外网IP最终到达内网的主机？另外如果两台主机是通过局域网IP通信，情况会有什么区别？</p></div><div id="vx2ax3" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>两台主机通过内网IP通信的方式如下：</p><p>在以太网中MAC地址才是真正用来进行数据传输的物理地址，主机A通过TCP/IP的ARP协议，从主机A的ARP高速缓存表中找到 某个IP对应MAC地址，然后向这个MAC地址发送数据。</p><p>那么假设是外网的主机，通过一个外网IP地址访问内网服务器，那么这个外网IP是怎么映射到内网服务器的？</p><p>参考答案：一般是借助网络设备（比如路由器），外部应用通过域名DNS，解析成一个外网IP，外网请求通过IP找到连接公网的网络设备（比如路由器）的Mac地址，然后把数据传输给这个网络设备，网络设备再根据IP在自己的ARP缓存表中找到真实的、与IP对应的内网主机Mac地址，然后把数据转发过去。【参见ARP欺骗、路由欺骗原理】</p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#38zc3c').fadeToggle(100);"><p><strong>题干=</strong></p><p>在服务器高可用方案中我们经常使用到的虚IP，是什么原理？</p></div><div id="38zc3c" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>虚IP，就是一个未分配给真实主机的IP，也就是说对外提供数据库服务器的主机除了有一个真实IP外还有一个虚IP，使用这两个IP中的 任意一个都可以连接到这台主机，所有项目中数据库链接一项配置的都是这个虚IP，当服务器发生故障无法对外提供服务时，动态将这个虚IP切换到备用主机。</p><p>&nbsp; &nbsp; 开始我也不明白这是怎么实现的，以为是软件动态改IP地址，其实不是这样，其实现原理主要是靠TCP/IP的ARP协议。因为ip地址只是一个逻辑 地址，在以太网中MAC地址才是真正用来进行数据传输的物理地址，每台主机中都有一个ARP高速缓存，存储同一个网络内的IP地址与MAC地址的对应关 系，以太网中的主机发送数据时会先从这个缓存中查询目标IP对应的MAC地址，会向这个MAC地址发送数据。操作系统会自动维护这个缓存。这就是整个实现 的关键。</p><p>&nbsp; &nbsp; 下边就是我电脑上的arp缓存的内容。</p><p>(192.168.1.219) at <span style="color: rgb(192, 0, 0);">00:21:5A:DB:68:E8</span> [ether] on bond0</p><p>(192.168.1.217) at <span style="color: rgb(192, 0, 0);">00:21:5A:DB:68:E8</span> [ether] on bond0</p><p>(192.168.1.218) at 00:21:5A:DB:7F:C2 [ether] on bond0</p><p>192.168.1.217、192.168.1.218是两台真实的电脑，192.168.1.219为虚IP。</p><p>192.168.1.217为对外提供数据库服务的主机，192.168.1.218为热备的机器。</p><p>注意219、217的MAC地址是相同的。</p><p>再看看那217宕机后的arp缓存</p><p>(192.168.1.219) at <span style="color: rgb(192, 0, 0);">00:21:5A:DB:7F:C2</span> [ether] on bond0</p><p>(192.168.1.217) at 00:21:5A:DB:68:E8 [ether] on bond0</p><p>(192.168.1.218) at <span style="color: rgb(192, 0, 0);">00:21:5A:DB:7F:C2</span> [ether] on bond0</p><p>&nbsp; &nbsp; 这就是奥妙所在。当218发现217宕机后会向网络发送一个<span style="text-decoration: underline;">ARP数据包</span>（备注1），告诉所有主机192.168.1.219这个IP对应的MAC地址是00:21:5A:DB:7F:C2，这样所有发送到219的数据包都会发送到mac地址为00:21:5A:DB:7F:C2的机器，也就是218的机器。</p><p style='line-height: 1;'><br/></p><p>备注1：好像是需要在218上安装keepalived服务，通过keepalived才能监测到217宕机，通过它来向网络发送这个ARP数据包。此处所说的网络，好像是指局域网？？</p><p>备注2：如果主机A未在自己的ARP缓存表中找到某IP，则A广播一个ARP请求报文（携带主机B的IP地址），网上所有主机都收到ARP请求，但只有对应的主机识别出自己的IP地址，于是向A主机发回一个ARP响应报文。A接收到应答后，就会更新本地的ARP缓存。</p><p>备注3：虚IP在操作系统上可以直接配置，相当于一个网卡自身就支持多个IP，不需要其他辅助。</p><p>备注4：Windows下可以使用 arp -a指令查看ARP缓存表。</p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#pzax6x').fadeToggle(100);"><p><strong>题干=</strong></p><p>keepalived的工作原理是什么？</p></div><div id="pzax6x" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>Keepalived是一个基于VRRP协议（Virtual Router Redundancy Protocol，即 虚拟路由冗余协议）来实现的服务高可用方案，可以利用其来避免IP单点故障。VRRP是实现路由器高可用的容错协议，即将N台提供相同功能的路由器组成一个路由器组(Router Group)，这个组里面有一个master和多个backup，但在外界看来就像一台一样，构成虚拟路由器，拥有一个虚拟IP（vip，也就是路由器所在局域网内其他机器的默认路由），占有这个IP的master实际负责ARP响应和转发IP数据包，组中的其它路由器作为备份的角色处于待命状态。master会发组播消息，当backup在超时时间内收不到vrrp包时就认为master宕掉了，这时就需要根据VRRP的优先级来选举一个backup当master，保证路由器的高可用。</p><p>&nbsp; &nbsp; 接上面的虚IP，举个说明：</p><p>主机A-- ip地址:ipA ；mac地址:macA</p><p>备机B-- ip地址:ipB ；mac地址:macB</p><p>虚拟ip地址: vip</p><p>&nbsp; &nbsp; keepalived分别安装在主机A和备机B上，双方启动以后，主机A就会向局域网内发送arp响应包，该arp响应包的ip地址被设为vip，mac地址被设为macA，所有接收的此报文的电脑就会将这个对应关系写入自己的ARP缓存表中,下次访问vip时，就会根据对应的mac地址访问到主机A</p><p>&nbsp; &nbsp; 当备机B（通过keepalived）监听到主机A挂了的时候，备机B就会被选举为VRP路由器组的master，然后向局域网内发送arp数据包，这个arp数据包的ip地址设为vip，mac地址设为macB，所有接收的此报文的电脑就会将这个对应关系写入自己的ARP缓存表中,下次访问vip时，就会根据对应的mac地址访问到备机B。这样就实现了高可用。</p><p>&nbsp; &nbsp; 也就是说，在这个过程中 keeplived有两方面的作用，一是监听主机的状态，二是在主机挂掉之后，发送ARP数据包给局域网内机器。</p><p style='line-height: 1;'><br/></p></div>
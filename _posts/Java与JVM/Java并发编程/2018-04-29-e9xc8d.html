---
layout: post
publishTime: 2018-04-29
category: Java与JVM
tags: [Java并发编程, volatile]
---

<div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#cz8x4n').fadeToggle(100);"><p><strong>题干=</strong></p><p>说说Java中的关键字 volatile 的原理和作用？</p><p>volatile boolean stop = false;</p></div><div id="cz8x4n" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>&nbsp; &nbsp; Java语言规范中指出：为了获得最佳速度，允许线程保存共享成员变量的私有拷贝，而且只当线程进入或者离开同步代码块时才与共享成员变量的原始值对比。这样当多个线程同时与某个对象交互时，就必须要注意到要让线程及时的得到共享成员变量的变化。</p><p>&nbsp; &nbsp; volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</p><p>&nbsp; &nbsp; 使用建议：在两个或者更多的线程访问的成员变量上使用volatile。当要访问的变量已在synchronized代码块中，或者为常量时，不必使用。由于使用volatile屏蔽掉了VM中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字。&nbsp;<br/></p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#5x6edz').fadeToggle(100);"><p><strong>题干=</strong></p><p>volatile类型变量提供什么保证？</p></div><div id="5x6edz" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>volatile&nbsp;主要有两方面的作用：1. 避免指令重排， 2.可见性保证。</p><ol class=" list-paddingleft-2" style="list-style-type: decimal;"><li><p>JVM&nbsp;或者&nbsp;JIT为了获得更好的性能会对语句重排序，但是&nbsp;volatile&nbsp;类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序；</p></li><li><p>volatile&nbsp;提供&nbsp;happens-before&nbsp;的保证，确保一个线程的修改能对其他线程是可见的；</p></li><li><p>某些情况下，volatile&nbsp;还能提供原子性，如读&nbsp;64&nbsp;位数据类型，像&nbsp;long&nbsp;和&nbsp;double&nbsp;都不是原子的(低32位和高32位)，但&nbsp;volatile&nbsp;类型的&nbsp;double&nbsp;和&nbsp;long&nbsp;就是原子的。</p></li></ol><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#93vyya').fadeToggle(100);"><p><strong>题干=</strong></p><p>volatile int 和 AtomicInteger的区别？</p><p>volatile boolean 和 AtomicBoolean的区别？</p></div><div id="93vyya" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>区别在于：</p><ol class=" list-paddingleft-2" style="list-style-type: decimal;"><li><p>AtomicBoolean提供了原子的方法，例如compareAndSet, getAndSet，而volatile boolean要达到同样的效果需要多步运算，且需要放到同步块中；</p></li><li><p>实际上两者的用途不一样，volatile boolean主要用于while(bool)这种简单的判断场景，AtomicBoolean则可以用于更加复杂的运算场景。</p></li></ol><p style='line-height: 1;'><br/></p></div>
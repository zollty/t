---
layout: post
publishTime: 2018-05-14
category: Java与JVM
tags: [JVM原理及结构, ClassLoader]
---

<div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#xxhu9c').fadeToggle(100);"><p><strong>题干=</strong></p><p>请说出5种以上的JVM GC算法，及它们的特点（优缺点）。</p><p>JVM的GC算法配置有哪些？</p></div><div id="xxhu9c" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>新生代：Serial、ParNew、Parallel Scavenge</p><p>老年代：Serial Old（MSC， Mark-Sweep-Compact）、Parallel Old、CMS（Concurrent Mark Sweep）</p><p>跨新生代和老年代的：G1</p><p>特点：</p><p>Parallel Scavenge适合关注吞吐量，而对停顿时间并不敏感的程序，例如后台批处理型应用、离线计算和统计等。</p><p>CMS由于停顿时间短，适合对交互时间敏感的程序。另外CMS本身比较耗CPU和内存。</p><p style='line-height: 1;'><br/></p><p>优缺点：</p><p>Serial收集器，串行收集器是最古老，最稳定以及效率高的收集器，但可能会产生较长的停顿，只使用一个线程去回收。</p><p>ParNew收集器，ParNew收集器其实就是Serial收集器的多线程版本。</p><p>Parallel收集器，Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。</p><p>Parallel Old收集器，Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程“标记－整理”算法</p><p>CMS收集器，CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它需要消耗额外的CPU和内存资源，在CPU和内存资源紧张，CPU较少时，会加重系统负担。CMS无法处理浮动垃圾。CMS的“标记-清除”算法，会导致大量空间碎片的产生。</p><p>G1收集器，G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征。</p><p style='line-height: 1;'><br/></p><p>JVM GC算法配置有如下：</p><p>-XX:+UseParNewGC：ParNew + Serial Old<br/></p><p>-XX:+UseParallelGC：Parallel Scavenge + Serial Old<br/></p><p>-XX:+UseParallelOldGC：Parallel Scavenge + Parallel Old<br/></p><p>-XX:+UseConcMarkSweepGC: ParNew + CMS + Serial Old</p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#cvyv88').fadeToggle(100);"><p><strong>题干=</strong></p><p>JVM垃圾回收机制，何时触发MinorGC？</p></div><div id="cvyv88" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>Eden空间满之后（或者说当分配一个对象时，Eden空间不足时），会触发一次MinorGC，将所有Eden存活下来的对象转移到其中一个survivor区（假设为s0）。</p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#x36cv7').fadeToggle(100);"><p><strong>题干=</strong></p><p>JVM 中一次完整的 GC 流程（从 ygc 到 fgc）是怎样的？</p><p>简述Minor GC和Major GC？</p></div><div id="x36cv7" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>1111</p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#z3e43a').fadeToggle(100);"><p><strong>题干=</strong></p><p>JVM 年轻代到年老代的晋升过程的判断条件是什么呢？</p></div><div id="z3e43a" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;1、部分对象会在From和To区域中复制来复制去,如此交换15次(由JVM参数MaxTenuringThreshold决定,这个参数默认是15),最终如果还是存活,就存入到老年代。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;2、如果对象的大小大于Eden的二分之一会直接分配在old，如果old也分配不下，会做一次majorGC，如果小于eden的一半但是没有足够的空间，就进行minorgc也就是新生代GC。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;3、minor gc后，survivor仍然放不下，则放到老年代；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;4、动态年龄判断 ，大于等于某个年龄的对象超过了survivor空间一半 ，大于等于某个年龄的对象直接进入老年代。</p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#z8e66k').fadeToggle(100);"><p><strong>题干=</strong></p><p>JVM 出现 fullGC 很频繁，怎么去线上排查问题？</p></div><div id="z8e66k" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>这题就依据full GC的触发条件来做：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Old空间不足，Perm空间不足，调用方法System.gc() ，ygc时的悲观策略，dump live的内存信息时(jmap –dump:live)，都会执行full gc。</p><p>1、full gc频繁说明old区快满了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;如果是一次fullgc后，剩余的对象不多，那么说明你的Eden区设置得太小了，导致短生命对象进入old区。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;或者看是不是频繁创建了大对象（大对象直接分配在老年代中）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;如果一次fullgc后，old区回收率不大，那么说明old区太小。</p><p>2、显示调用了System.gc()？？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;这个一般没人去调用吧~~~</p><p>3、如果有perm gen的话(jdk1.8以下)，看看是不是perm gen区的值设置得太小了</p><p>&nbsp;&nbsp;&nbsp;&nbsp;要给perm gen分配空间，但没有足够的空间时，会触发full gc。</p><p style='line-height: 1;'><br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;参见：<a href="https://blog.csdn.net/chenleixing/article/details/46706039/">https://blog.csdn.net/chenleixing/article/details/46706039/</a> </p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#xv2gz5').fadeToggle(100);"><p><strong>题干=</strong></p><p>说一下G1垃圾收集器的特点</p></div><div id="xv2gz5" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>参见：</p><p><a href="https://www.jianshu.com/p/0f1f5adffdc1">https://www.jianshu.com/p/0f1f5adffdc1</a> </p><p><a href="https://blog.csdn.net/android_app/article/details/77636090">https://blog.csdn.net/android_app/article/details/77636090</a></p><p><a href="https://liuzhengyang.github.io/2017/06/07/garbage-first-collector/">https://liuzhengyang.github.io/2017/06/07/garbage-first-collector/</a></p><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#garbage_first_garbage_collection">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#garbage_first_garbage_collection</a></p><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html</a></p><p>G1相比较于CMS的优势：</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>G1是一种适用于服务器端的垃圾回收器，很好的平衡了吞吐量和响应能力</p></li><li><p>对于内存的划分方法不同，Eden, Survivor, Old区域不再固定，使用内存会更高效。G1通过对内存进行Region的划分，有效避免了内存碎片问题。</p></li><li><p>G1可以指定GC时可用于暂停线程的时间（不保证严格遵守）。而CMS并不提供可控选项。</p></li><li><p>CMS只有在FullGC之后会重新合并压缩内存，而G1把回收和合并集合在一起。</p></li><li><p>CMS只能使用在Old区，在清理Young时一般是配合使用ParNew，而G1可以统一两类分区的回收算法。</p></li></ul><p>G1的适用场景：</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>JVM占用内存较大(At least 4G)</p></li><li><p>应用本身频繁申请、释放内存，进而产生大量内存碎片时。</p></li><li><p>对于GC时间较为敏感的应用。</p></li></ul><p>另外，</p><p>1、Kafka官方文档里推荐使用最新的G1来代替CMS作为垃圾回收器。不过也明确指出在某些低版本(1.7u21)的JDK上还是会存在一些不稳定的问题。推荐使用的最低版本为JDK 1.7u51。下面是本次试验中Broker的JVM内存配置参数：</p><p>-Xms30g -Xmx30g -XX:PermSize=48m -XX:MaxPermSize=48m -XX:+UseG1GC -XX:MaxGCPauseMillis=20 -XX:InitiatingHeapOccupancyPercent=35</p><p>2、ElasticSearch：Java大内存进程使用G1更有优越性，没有survivor的浪费和fgc易导致cpu飙高，G1的大部分参数不需要设置，jvm会自动动态优化。</p><p>-XX:+UseG1GC -Xss10m -XX:MaxGCPauseMillis=800 -XX:ParallelGCThreads=15 -XX:ConcGCThreads=4<br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;使用G1时不要配置-Xmn和-XX:NewRatio。（参照<a href="http://www.oracle.com/technetwork/articles/java/g1gc-1984535.html">http://www.oracle.com/technetwork/articles/java/g1gc-1984535.html</a>）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<em>Young Generation Size: Avoid explicitly setting young generation size with the -Xmn option or any or other related option such as -XX:NewRatio. Fixing the size of the young generation overrides the target pause-time goal.</em></p><p>&nbsp;&nbsp;&nbsp;&nbsp;-Xss10m线程最大栈设置，如果出现过stackoverflow，需要调大此参数，我们es的线程数不多可以适当调大（pstree -p [pid] | wc -l）；堆大小不变该参数调大则能创建的线程数将减少。<br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;-XX:MaxGCPauseMillis默认200，后台任务不追求最快响应时间，追求最大吞吐量需适当调大</p><p>&nbsp;&nbsp;&nbsp;&nbsp;-XX:ParallelGCThreads设为cpu的逻辑核数，如果逻辑核数超过8则设为5/8，我们机器是24个逻辑核，所以设为15</p><p>&nbsp;&nbsp;&nbsp;&nbsp;-XX:ConcGCThreads设为-XX:ParallelGCThreads的1/4</p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#aex7he').fadeToggle(100);"><p><strong>题干=</strong></p><p>How to&nbsp;Selecting a Garbage Collector？</p></div><div id="aex7he" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>If the application has a small data set (up to approximately 100 MB), then select the serial collector with the option -XX:+UseSerialGC.</p></li><li><p>If the application will be run on a single processor and there are no pause time requirements, then let the VM select the collector, or select the serial collector with the option -XX:+UseSerialGC.</p></li><li><p>If (a) peak application performance is the first priority and (b) there are no pause time requirements or pauses of 1 second or longer are acceptable, then let the VM select the collector, or select the parallel collector with -XX:+UseParallelGC.</p></li><li><p>If response time is more important than overall throughput and garbage collection pauses must be kept shorter than approximately 1 second, then select the concurrent collector with -XX:+UseConcMarkSweepGC or -XX:+UseG1GC.</p></li></ul><p>参见：<br/></p><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html</a> </p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#k4zc4g').fadeToggle(100);"><p><strong>题干=</strong></p><p>如何进行JVM、GC调优？</p></div><div id="k4zc4g" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p><a href="https://blog.csdn.net/lizhitao/article/details/44677659">https://blog.csdn.net/lizhitao/article/details/44677659</a></p><p><a href="http://www.cnblogs.com/zhangpan1244/p/6197832.html">http://www.cnblogs.com/zhangpan1244/p/6197832.html</a></p><p><a href="https://www.java123.vip/wp/">https://www.java123.vip/wp/</a></p><p><a href="http://www.importnew.com/23780.html">http://www.importnew.com/23780.html</a></p><p><a href="https://www.cnblogs.com/csniper/p/5592593.html">https://www.cnblogs.com/csniper/p/5592593.html</a></p><p><a href="http://youzhixueyuan.com/jvm-performance-optimization.html">http://youzhixueyuan.com/jvm-performance-optimization.html</a></p><p>参见官方文档：</p><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html</a> </p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#bazuyz').fadeToggle(100);"><p><strong>题干=</strong></p><p>有哪些JVM调优和监控的命令和工具？大概用法</p></div><div id="bazuyz" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>参见：<a href="http://www.importnew.com/23761.html">http://www.importnew.com/23761.html</a> </p><p><a href="http://www.importnew.com/23786.html">http://www.importnew.com/23786.html</a> </p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#y7ax3x').fadeToggle(100);"><p><strong>题干=</strong></p><p>eden survivor区的比例，为什么是这个比例，eden survivor的工作过程。</p></div><div id="y7ax3x" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>？？</p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#z8c394').fadeToggle(100);"><p><strong>题干=</strong></p><p>JVM常见参数的作用</p></div><div id="z8c394" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>-Xmx:最大堆内存,如:-Xmx512m</p><p>-Xms:初始时堆内存,如:-Xms256m</p><p>-XX:MaxNewSize:最大年轻区内存&nbsp;</p><p>-XX:NewSize:初始时年轻区内存，通常为 Xmx 的 1/3 或 1/4。</p><p>新生代 = Eden + 2 个 Survivor 空间。实际可用空间为 = Eden + 1 个 Survivor，即 90%</p><p>-XX:MaxPermSize:最大持久带内存-XX:PermSize:初始时持久带内存-XX:+PrintGCDetails。打印 GC 信息</p><p> -XX:NewRatio 新生代与老年代的比例，如 –</p><p>XX:NewRatio=2，则新生代占整个堆空间的1/3，老年代占2/3</p><p> -XX:SurvivorRatio 新生代中 Eden 与 Survivor 的比值。默认值为 8。即 Eden 占新生代空间的 8/10，另外两个 Survivor 各占 1/10栈：</p><p>-xss:设置每个线程的堆栈大小. JDK1.5+ 每个线程堆栈大小为 1M，一般来说如果栈不是很深的话， 1M 是绝对够用了的。List集合存储元素特点？</p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#5ea7c4').fadeToggle(100);"><p><strong>题干=</strong></p><p>Java中OutOfMemoryError(内存溢出)的三种情况及解决办法</p></div><div id="5ea7c4" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>参见：</p><p><a href="http://blog.sina.com.cn/s/blog_701c951f0100n1sp.html">http://blog.sina.com.cn/s/blog_701c951f0100n1sp.html</a> </p><p><a href="https://mars914.iteye.com/blog/1446497">https://mars914.iteye.com/blog/1446497</a> </p><p style='line-height: 1;'><br/></p></div>
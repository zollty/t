---
layout: post
publishTime: 2018-05-14
category: Java与JVM
tags: [JVM原理及结构]
---

<div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#y7xgcy').fadeToggle(100);"><p><strong>题干=</strong></p><p>Java代码的编译过程？</p></div><div id="y7xgcy" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p><strong>源代码</strong>---词法分析---语法分析---语义分析---字节码生成器---<strong>字节码</strong></p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#2zgkyz').fadeToggle(100);"><p><strong>题干=</strong></p><p>Java Class文件的加载过程？</p></div><div id="2zgkyz" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>会用到JIT编译器，如下：</p><p><strong>字节码</strong>---JIT Compiler(Just-in-time Compiler) 即时编译---对应操作系统的<strong>目标代码</strong></p><p style='line-height: 1;'><br/></p><p>1、将类装入JVM中</p><p>在Java中，类装载器把一个类装入JVM中，要经过以下步骤：</p><p style='line-height: 1;'><br/></p><p>&nbsp; &nbsp; &nbsp;(1) 装载：查找和导入Class文件；</p><p>&nbsp; &nbsp; &nbsp;(2) 链接：把类的二进制数据合并到JRE中；</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;校验：检查载入Class文件数据的正确性；</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;准备：给类的静态变量分配存储空间；</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;解析：将符号引用转成直接引用；</p><p>&nbsp; &nbsp; &nbsp;(3) 初始化：对类的静态变量，静态代码块执行初始化操作</p><p style='line-height: 1;'><br/></p><p>2、通过ClassLoader加载类</p><p>1）Bootstrap ClassLoader</p><p>负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类</p><p style='line-height: 1;'><br/></p><p>2）Extension ClassLoader</p><p>负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包</p><p style='line-height: 1;'><br/></p><p>3）App ClassLoader</p><p>负责记载classpath中指定的jar包及目录中class</p><p style='line-height: 1;'><br/></p><p>4）Custom ClassLoader</p><p>属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader</p><p style='line-height: 1;'><br/></p><p>加载过程中会先检查类是否被已加载，<strong>检查顺序是自底向上</strong>，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而<strong>加载的顺序是自顶向下</strong>，也就是由上层来逐层尝试加载此类。</p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#8a7x9z').fadeToggle(100);"><p><strong>题干=</strong></p><p>Java代码的执行过程？</p></div><div id="8a7x9z" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>JVM是基于栈执行的，每个线程会建立一个操作栈，每个栈又包含了若干个栈帧，每个栈帧包含了局部变量、操作数栈、动态连接、方法的返回地址信息等。</p><p style='line-height: 1;'><br/></p><p>线程创建后，都会产生程序计数器（PC）和栈（Stack），程序计数器存放下一条要执行的指令在方法内的偏移量，栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是有局部变量区和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果。</p><p style='line-height: 1;'><br/></p><p>虚拟机<strong>栈</strong>也是线程私有的，每创建一个线程，虚拟机就会为这个线程创建一个虚拟机栈，虚拟机栈表示Java方法执行的内存模型，<strong>每调用一个方法，就会生成一个栈帧</strong>（Stack Frame）用于存储方法的本地变量表、操作栈、方法出口等信息，当这个方法执行完后，就会弹出相应的栈帧。</p><p style='line-height: 1;'><br/></p><p>如果请求的栈的深度过大，虚拟机可能会抛出StackOverflowError异常。</p><p style='line-height: 1;'><br/></p></div>
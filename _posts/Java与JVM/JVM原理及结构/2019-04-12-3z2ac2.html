---
layout: post
publishTime: 2019-04-12
category: Java与JVM
tags: [JVM原理及结构]
---

<div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#6cvd7x').fadeToggle(100);"><p><strong>题干=</strong></p><p>JVM的Run-Time Data Areas（运行时数据区）包含哪些部分？</p></div><div id="6cvd7x" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>包含如下 5个部分：</p><ol class=" list-paddingleft-2" style="list-style-type: decimal;"><li><p><span style="color: rgb(192, 0, 0);">The pc Register</span>（程序计数器，Program Counter Register）</p></li><li><p><span style="color: rgb(192, 0, 0);">JVM Stacks</span>（虚拟机栈，包含很多 “栈帧Frame”）</p><p><span style="font-size: 12px;">—— 在JVM Spec v1.0版本中 叫做 “Java Stack”</span></p></li><li><p><span style="color: rgb(192, 0, 0);">Heap</span>（堆）<br/></p></li><li><p><span style="color: rgb(192, 0, 0);">Method Area</span>（方法区）</p><p>方法区包括：<span style="color: rgb(192, 0, 0);">Run-Time Constant Pool</span>（运行时常量池）</p></li><li><div><p><span style="color: rgb(192, 0, 0);">Native Method Stacks</span>（本地方法栈）</p></div></li></ol><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#4x7k8z').fadeToggle(100);"><p><strong>题干=</strong></p><p>JVM Stack的Frame（帧）包含哪些部分？</p></div><div id="4x7k8z" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>Frame包含如下内容：</p><ol class=" list-paddingleft-2" style="list-style-type: decimal;"><li><p>Local Variables Array （局部变量，数组）</p></li><li><p>Operand Stacks（操作数栈，LIFO stack）</p></li><li><p>Dynamic Linking（动态链接）</p><p>a reference to the <span style="text-decoration: none;">run-time constant pool&nbsp;</span>of the class of the current method.<br/></p></li><li><p>Return Address</p><p><span style="font-size: 14px;"><em>Normal Method Invocation Completion（方法返回地址——正常完成出口）</em></span></p><p><span style="font-size: 14px;"><em>Abrupt Method Invocation Completion（方法返回地址——异常完成出口）</em></span></p></li><li><p>Extended information （扩展信息，取决于具体实现，例如debug信息）<br/></p></li></ol><p>其中，一般把（动态链接、方法返回地址、附加信息）统称 “帧栈信息”。</p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#46yx4a').fadeToggle(100);"><p><strong>题干=</strong></p><p>对于Java Stack（虚拟机栈） 和 Native method Stack（本地方法栈），定义了哪两种常见的异常？</p></div><div id="46yx4a" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>在Java虚拟机规范中，对虚拟机栈和本地方法栈区域规定了两种异常状况：</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；</p></li><li><p>如果虚拟机可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p></li></ul><p>在Hot Spot虚拟机中，可以使用-Xss参数来设置栈的大小。栈的大小直接决定了函数调用的可达深度。</p><p>另外：程序计数器是java虚拟机中唯一一块不会产生error的内存区域。</p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#gcynaz').fadeToggle(100);"><p><strong>题干=</strong></p><p>为什么说：“程序计数器是java虚拟机中唯一一块不会产生error的内存区域”？</p></div><div id="gcynaz" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;首先要知道JVM的内存区域有哪些？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;一共5个：堆、方法区、JVM Stack、pc Register、本地方法栈</p><p>&nbsp;&nbsp;&nbsp;&nbsp;除了pc Register区域外，其他区域均可能产生异常。显然，堆、方法区是可能出现 内存不够用的，比如常见的内存不足会报错：java.lang.OutOfMemoryError:Java heap space，永久代也可能报错：java.lang.OutOfMemoryError: PermGen space，新版JVM的元数据区虽然有所好转，但仍然可能报错，而JVM Stack区域可能出现OutOfMemoryError和StackOverflowError，本地方法栈也一样。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;而pc Register区域是一块较小的线程私有的内存空间，只存放线程下一条需要执行的字节码指令，在这个区域不存在任何异常。</p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#59c7ea').fadeToggle(100);"><p><strong>题干=</strong></p><p>StackOverflowError异常是怎么产生的？</p><p>JVM 参数 Xss有什么作用？</p><p>如何估计JVM的最大线程数量？</p></div><div id="59c7ea" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;JVM线程执行，是基于Stack的，它是一个LIFO的数据结构（里面装的是Frame），每次调用方法时都会创建一个新Frame（里面包含了方法信息、局部变量等），执行完或遇到异常之后出栈，帧栈内存被回收。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;JVM Spec规定，堆栈可以是动态大小或固定大小。如果线程执行方法的深度很深，那么压入的帧栈很多，这些Frame一直出不了栈，内存得不到回收，那么超过了某个最大值就会引发StackOverflowError。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;JVM可以通过-Xss 参数 来 设置每个线程的堆栈大小，JDK5.0以后每个线程堆 栈大小为1M。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;查看JVM 默认Xss的方法为：</p><pre class="brush:bash;toolbar:false">java&nbsp;-XX:+PrintFlagsFinal&nbsp;-version&nbsp;|&nbsp;grep&nbsp;ThreadStackSize

intx&nbsp;CompilerThreadStackSize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{pd&nbsp;product}
intx&nbsp;ThreadStackSize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;1024&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{pd&nbsp;product}
intx&nbsp;VMThreadStackSize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;1024&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{pd&nbsp;product}

java&nbsp;version&nbsp;&quot;1.8.0_151&quot;
Java(TM)&nbsp;SE&nbsp;Runtime&nbsp;Environment&nbsp;(build&nbsp;1.8.0_151-b12)
Java&nbsp;HotSpot(TM)&nbsp;64-Bit&nbsp;Server&nbsp;VM&nbsp;(build&nbsp;25.151-b12,&nbsp;mixed&nbsp;mode)</pre><p>&nbsp; &nbsp; 或者执行命令：jinfo -flag ThreadStackSize ${pid}，参见<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" target="_blank" style="background-color: rgb(245, 245, 213);">JDK配置文档</a>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;一个线程对应的栈所占据的内存空间和他每个栈帧占据的空间息息相关。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;从<a href="https://blog.csdn.net/a397525088/article/details/81702547" target="_blank">这个实验</a>可以看出，局部变量表内容越多，栈帧越大，栈深度越小。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;也就是说，在Hot Spot VM中，栈的最大深度和 具体每个栈的内存占用大小，及总的可用栈内存大小有关。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;虚拟机栈的最大总内存大致上等于</p><pre class="brush:plain;toolbar:false">虚拟机栈的最大总内存&nbsp;≈&nbsp;JVM&nbsp;进程&nbsp;能占用的最大内存(依赖于具体操作系统和配置）
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;最大堆内存&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;最大方法区内存&nbsp;-&nbsp;程序计数器内存（可以忽略不计）&nbsp;-&nbsp;JVM进程本身消耗内存</pre><p>&nbsp;&nbsp;&nbsp;&nbsp;考虑到 如下两点：</p><p>&nbsp; &nbsp; 1 JVM进程（64位操作系统）的最大内存限制通常是非常大的（据说是 数以T计），</p><p>&nbsp;&nbsp;&nbsp;&nbsp;2 除了堆内存，其他JVM的内存占用较小。<br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;故上面的公式可简化为：</p><pre class="brush:plain;toolbar:false">虚拟机栈的最大总内存&nbsp;≈&nbsp;机器本身的可用内存&nbsp;-&nbsp;JVM分配的堆内存</pre><p>&nbsp; &nbsp; 知道了栈深度的原理，对JVM调优有什么用呢？</p><p>&nbsp; &nbsp; 1、当我们定义的方法参数和局部变量过多，字节过大，考虑到可能会导致栈深度减小，这个时候就需要手动的增加栈的深度（例如java -Xss2m，-Xss128k），栈的最大深度 越深，能执行的递归调用次数就越多。</p><p>&nbsp; &nbsp; 2、在相同物理内存下，减小-Xss值能生成更多的线程。</p><p>&nbsp; &nbsp; 不考虑系统限制，可以通过如下公式计算，得出最大线程数量：</p><pre class="brush:plain;toolbar:false">最大线程数量&nbsp;=（虚拟机栈的最大内存）/&nbsp;Xss的值</pre><p>&nbsp; &nbsp; 根据上面计算 虚拟机栈的最大总内存公式可知，假如一个容器本身大小是8G，堆大小是4096M，走-Xss默认值（1M），可以得出 最大线程数量：4096个。实际上肯定会小于这个值。</p><p>&nbsp; &nbsp; 上面是不考虑系统限制的情况，操作系统可能对一个进程内的线程数有限制，不能无限生成，经验值在3000~5000左右，具体要查询操作系统的相关配置。主要跟以下几个参数有关系:</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>/proc/sys/kernel/pid_max 增大，线程数量增大，pid_max有最高值，超过之后不再改变，而且32/64位也不一样；</p></li><li><p>/proc/sys/kernel/thread-max 系统可以生成的最大线程数量；</p></li><li><p>max_user_process（ulimit -u）centos系统上才有，没有具体研究；</p></li><li><p>/proc/sys/vm/max_map_count 增大，数量增多。</p></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;另外，虚拟机栈的最大总内存 不一定能达到4096M，上面说了，这个跟操作系统有关，据说32位操作系统，每个进程最大内存不超过2G。linux中每个进程内存大小的限制是多少？可以通过该命令 ulimit -a 查看，具体参见<a href="https://segmentfault.com/q/1010000004426669" target="_blank" style="background-color: rgb(245, 245, 213);">这篇文章</a>。</p><p style='line-height: 1;'><br/></p><p>另附两个问题：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;1. “-Xss1024m” 代表的是每个线程在创建启动时都会分配这个固定大小的内存吗，还是说这个内存是这个线程栈内存的最大值？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;答案：应该是固定分配的栈内存。<br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;2. 如何实时查看jvm虚拟机中每个线程占内存的大小？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;答案：参见下面的题目。</p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#22yezy').fadeToggle(100);"><p><strong>题干=</strong></p><p>如何实时查看jvm虚拟机中每个线程占内存的大小？</p></div><div id="22yezy" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>其实等价于查看 操作系统中某个进程的每个线程（pthread）所占内存的大小。<br/></p><p>答案：</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>输入top命令，按快捷键 SHITF + P 查看CPU占用最高的进程，按 SHIFT + M 查看内存占用最高的进程。找到进程pid。<br/></p></li><li><p>然后输出 top -Hp 找到的pid，然后使用快捷键&nbsp;SHIFT + P / M即可找到CPU或内存占用最高的线程。</p></li><li><p>如果还想看 JVM 线程的stack信息，则根据线程tid，转换成十六进制：printf &quot;%x\n&quot; 找到的tid，<br/></p></li><li><p>然后执行： jstack 进程pid | grep&nbsp;&#39;nid=0x{TID}&#39; -A 30（注意将{TID}替换成实际的tid）</p><p><em><span style="font-size: 14px;">建议先将 jstack信息导出到一个文件中，再进行grep或者用vim打开。</span></em></p></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;另外，再分享两个命令，</p><p>&nbsp;&nbsp;&nbsp;&nbsp;1. 根据进程的CPU占用率排序：</p><pre class="brush:bash;toolbar:false">top&nbsp;-H&nbsp;-b&nbsp;-n&nbsp;1&nbsp;-o&nbsp;&#39;%CPU&#39;（降序）</pre><p>或者</p><pre class="brush:bash;toolbar:false">ps&nbsp;H&nbsp;-eo&nbsp;user,pid,ppid,tid,time,%cpu,cmd&nbsp;--sort=%cpu（升序）</pre><p>&nbsp;&nbsp;&nbsp;&nbsp;2. 查看某个进程的 TOP 10的线程：</p><pre class="brush:bash;toolbar:false">top&nbsp;-H&nbsp;-p&nbsp;${pid}&nbsp;-b&nbsp;-n1&nbsp;|&nbsp;grep&nbsp;PID&nbsp;-A10&nbsp;|&nbsp;grep&nbsp;-v&nbsp;PID</pre><p>或者不要进程id，直接统计所有进程：</p><pre class="brush:bash;toolbar:false">ps&nbsp;Hh&nbsp;-eo&nbsp;pid,tid,pcpu&nbsp;|&nbsp;sort&nbsp;-nk3&nbsp;|tail</pre><p>&nbsp;&nbsp;&nbsp;&nbsp;分享一个脚本，可以查看指定pid的TOP 10的线程信息：<br/></p><pre class="brush:bash;toolbar:false">#!/bin/bash
[&nbsp;$#&nbsp;-ne&nbsp;1&nbsp;]&nbsp;&amp;&amp;&nbsp;exit&nbsp;1
jstack&nbsp;$1&nbsp;&gt;/tmp/jstack.log
top&nbsp;-H&nbsp;-p&nbsp;$1&nbsp;-b&nbsp;-n1&nbsp;|&nbsp;grep&nbsp;PID&nbsp;-A10&nbsp;|&nbsp;grep&nbsp;-v&nbsp;PID&nbsp;|&nbsp;awk&nbsp;&#39;{print$1,$9}&#39;&nbsp;&gt;/tmp/topH.log
cat&nbsp;/tmp/topH.log&nbsp;|&nbsp;while&nbsp;read&nbsp;tid&nbsp;cpu;do
&nbsp;&nbsp;xtid=`printf&nbsp;&quot;%x\n&quot;&nbsp;$tid`
&nbsp;&nbsp;echo&nbsp;-e&nbsp;&quot;\033[31m========================$xtid&nbsp;$cpu%\033[0m&quot;
&nbsp;&nbsp;cat&nbsp;/tmp/jstack.log&nbsp;|&nbsp;sed&nbsp;-n&nbsp;-e&nbsp;&quot;/0x$xtid/,/^$/&nbsp;p&quot;
done</pre><p>&nbsp;&nbsp;&nbsp;&nbsp;保存为 jthread.sh，执行：./jthread.sh ${pid}</p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#ac899c').fadeToggle(100);"><p><strong>题干=</strong></p><p>我们知道堆内存是有垃圾回收机制的，那么方法区的内存有垃圾回收机制吗？</p></div><div id="ac899c" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>JVM Spec文档所说：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;方法区的实现可以不需要垃圾回收或压缩，且对方法区所在的位置不做要求。</p><p>（Although the method area is logically part of the heap, simple implementations may choose not to either garbage collect or compact it.）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;在Sun/Oracle JDK的HotSpot VM中，直到JDK7，方法区被放置在“持久代”（Permanent Generation，简称PermGen），也即方法区。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Oracle JDK8的HotSpot VM去掉“持久代”，以“元数据区”（Metaspace）替代之。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Oracle是在JDK7的时候宣布移除PermGen内存区域，但是直到JDK8才最终移除。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;在JDK7之前，所谓的Permanent Generation内存区域其实包含了两个部分：<br/></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>&nbsp;&nbsp;&nbsp;&nbsp;the method area（方法区）</p></li><li><p>&nbsp;&nbsp;&nbsp;&nbsp;interned strings</p></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;方法区主要存储了class的一些信息，包括运行时常量池、Classloader的引用，字段数据，方法数据等等。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Interned String内存区域是在JDK 7的时候从JVM内存区域里面移除的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;这里有一篇关于移除PermGen内存区域的说明，有兴趣可以看下：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-September/006679.html">http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-September/006679.html</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;所以方法区在HotSpot VM中 是存在垃圾回收和压缩的，只不过通常不会有明显的效果。<br/></p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#bz99kx').fadeToggle(100);"><p><strong>题干=</strong></p><p>列举一下一个JVM进程主要占用的内存包括哪些部分？</p></div><div id="bz99kx" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>如下所示（包括但不限于此）：</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>Young</p></li><li><p>Old</p></li><li><p>metaspace（或PermGen）</p></li><li><p>java thread count * Xss</p></li><li><p>other thread count * stacksize （非Java线程）</p></li><li><p>Direct memory</p></li><li><p>native memory</p></li><li><p>Code Cache</p></li></ul><p>参考<a href="https://www.jianshu.com/p/0cbc4e44c596" target="_blank">这篇文章</a>。</p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#564kzx').fadeToggle(100);"><p><strong>题干=</strong></p><p>Java代码的执行过程？</p></div><div id="564kzx" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;JVM是基于栈执行的，每个线程会建立一个操作栈，每个栈又包含了若干个栈帧，每个栈帧包含了局部变量、操作数栈、动态连接、方法的返回地址信息等。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;线程创建后，都会产生程序计数器（PC）和栈（Stack），程序计数器存放下一条要执行的指令在方法内的偏移量，栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是有局部变量区和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;虚拟机栈也是线程私有的，每创建一个线程，虚拟机就会为这个线程创建一个虚拟机栈，虚拟机栈表示Java方法执行的内存模型，每调用一个方法，就会生成一个栈帧（Stack Frame）用于存储方法的本地变量表、操作栈、方法出口等信息，当这个方法执行完后，就会弹出相应的栈帧。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;如果请求的栈的深度过大，虚拟机可能会抛出StackOverflowError异常。<br/></p><p style='line-height: 1;'><br/></p></div>
---
layout: post
publishTime: 2018-04-29
category: Java与JVM
tags: [Java集合, BlockingQueue]
---

<div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#2ca7x3').fadeToggle(100);"><p><strong>题干=</strong></p><p>请详细分析LinkedBlockingQueue、ArrayBlockingQueue它们有什么不同，以及各自的最佳使用场景。</p></div><div id="2ca7x3" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>数据结构不同，Linked是基于链表，数据是包裹在Node&lt;E&gt;对象中，Node对象有next指针；Array是基于Object数组。相对来说，Linked占用的额外空间内存会大一些，特别是当数据量大时，内存开销可观，GC压力大。</p></li><li><p>在生产或消费时，Array是直接根据下标将对象从数组中循环取出或存入；而Linked插入时需要把对象转换为Node&lt;E&gt;对象，移除时需要修改指针。</p></li><li><p>并发锁的使用不同，Linked生产和消费是两个不同的锁，读写分离，生产操作尾节点用的putLock，消费操作头节点用的takeLock；而Array生产和消费都是操作的同一个数组，用的是同一把锁，之所以没有读写分离，是因为对数组的存入和取出操作是非常轻量的，以至于引入更多的锁，除了给代码带来额外的复杂性外，在性能上完全占不到任何便宜。</p></li><li><p>基于以上理论，以及实际性能测试，可以得出：当线程数非常多，并发非常严重的情况下，Array的性能还是不及Linked，当线程数很少，并发不严重的情况下，两者性能差不多甚至Array会更高效一些。但是当持续数据量大时，Linked需要频繁的创建和晓辉Node节点对象，会面临较大的GC压力，可能造成内存增高。</p></li></ul><p>参考资料：</p><p><a href="http://m.blog.csdn.net/article/details?id=46680565">http://m.blog.csdn.net/article/details?id=46680565</a></p><p><a href="http://blog.51cto.com/stevex/1287085">http://blog.51cto.com/stevex/1287085</a></p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#k5kx49').fadeToggle(100);"><p><strong>题干=</strong></p><p>BlockingQueue添加元素的方法有哪些？add，put，offer，它们的区别是什么？</p></div><div id="k5kx49" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>add：Inserts&nbsp;the&nbsp;specified&nbsp;element&nbsp;into&nbsp;this&nbsp;queue&nbsp;if&nbsp;it&nbsp;is&nbsp;possible&nbsp;to&nbsp;do&nbsp;so&nbsp;immediately&nbsp;without&nbsp;violating&nbsp;capacity&nbsp;restrictions,&nbsp;returning&nbsp;true&nbsp;upon&nbsp;success&nbsp;and&nbsp;throwing&nbsp;an&nbsp;IllegalStateException&nbsp;if&nbsp;no&nbsp;space&nbsp;is&nbsp;currently&nbsp;available.&nbsp;</p><p>This&nbsp;implementation&nbsp;returns&nbsp;true&nbsp;if&nbsp;offer&nbsp;succeeds,&nbsp;else&nbsp;throws&nbsp;an&nbsp;IllegalStateException.</p><p>add方法在添加元素的时候，若超出了度列的长度会直接抛出异常。</p><p>put：Inserts&nbsp;the&nbsp;specified&nbsp;element&nbsp;at&nbsp;the&nbsp;tail&nbsp;of&nbsp;this&nbsp;queue,&nbsp;waiting&nbsp;if&nbsp;necessary&nbsp;for&nbsp;space&nbsp;to&nbsp;become&nbsp;available.</p><p>对于put方法，若向队尾添加元素的时候发现队列已经满了会发生阻塞一直等待空间，以加入元素。</p><p>offer：Inserts&nbsp;the&nbsp;specified&nbsp;element&nbsp;at&nbsp;the&nbsp;tail&nbsp;of&nbsp;this&nbsp;queue&nbsp;if&nbsp;it&nbsp;is&nbsp;possible&nbsp;to&nbsp;do&nbsp;so&nbsp;immediately&nbsp;without&nbsp;exceeding&nbsp;the&nbsp;queue&#39;s&nbsp;capacity,&nbsp;returning&nbsp;true&nbsp;upon&nbsp;success&nbsp;and&nbsp;false&nbsp;if&nbsp;this&nbsp;queue&nbsp;is&nbsp;full.&nbsp;When&nbsp;using&nbsp;a&nbsp;capacity-restricted&nbsp;queue,&nbsp;this&nbsp;method&nbsp;is&nbsp;generally&nbsp;preferable&nbsp;to&nbsp;method&nbsp;add,&nbsp;which&nbsp;can&nbsp;fail&nbsp;to&nbsp;insert&nbsp;an&nbsp;element&nbsp;only&nbsp;by&nbsp;throwing&nbsp;an&nbsp;exception.</p><p>offer方法在添加元素时，如果发现队列已满无法添加的话，会直接返回false。</p><p>offer可以设置一个等待时间：offer(e,&nbsp;time,&nbsp;unit)</p><p>总结如下：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;抛出异常 &nbsp; &nbsp;特殊值 &nbsp; &nbsp; &nbsp; 阻塞 &nbsp; &nbsp; &nbsp;超时</p><p>插入 &nbsp; add(e) &nbsp; &nbsp; &nbsp; offer(e) &nbsp; &nbsp; put(e) &nbsp; &nbsp;offer(e,&nbsp;time,&nbsp;unit)</p><p>移除 &nbsp; remove() &nbsp; poll() &nbsp; &nbsp; &nbsp; &nbsp;take() &nbsp; &nbsp; poll(time,&nbsp;unit)</p><p>检查 &nbsp; element() &nbsp; peek() &nbsp; &nbsp; 不可用 &nbsp; &nbsp;不可用</p><p>注：peek()取head的值，和poll差不多，但peek不会删除元素也不会阻塞。</p><p style='line-height: 1;'><br/></p></div>
---
layout: post
publishTime: 2018-04-29
category: Java与JVM
tags: [Java集合, HashMap]
---

<div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#9yc6c8').fadeToggle(100);"><p><strong>题干=</strong></p><p>HashMap、Hashtable、LinkedHashMap、TreeMap、ConcurrentHashMap的区别</p></div><div id="9yc6c8" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>它们都实现了Map接口，除了过时的Hashtable外，其他几个都继承了AbtsractMap抽象类。</p><p>1） 首先，Hashtable和ConcurrentHashMap是线程安全的，支持线程同步，二者功能差不多，ConcurrentHashMap可以看作是旧的Hashtable的替代。ConcurrentHashMap采用了锁分段技术和弱一致性的Map迭代器去规避并发瓶颈，效率比Hashtable高。它们都不支持null的key或者value。</p><p>2） LinkedHashMap继承自HashMap，除了允许空值（key或value可以为null）和不支持同步（非线程安全），HashMap和Hashtable没有什么区别。其中LinkedHashMap是在HashMap的基础上增加了双向链表，存储的元素有固定的迭代顺序，而且具有链表的一些优势，遍历很高效（和size成正比），但在做add, contains, remove等操作时，由于要维护链表结构，效率比HashMap要低一些。</p><p>3） TreeMap基于红黑树数据结构的实现，键值可以使用Comparable或Comparator接口来自动排序。TreeMap是非线程安全的。因为主要用来根据key值排序，所以key值一般不为null。</p><p style='line-height: 1;'><br/></p><p>补充：Hashtable</p><p>Hashtable是个过时的集合类，存在于Java API中很久了，基于陈旧的Dictionary抽象类实现。在Java 4中被重写了，实现了Map接口。</p><p>Hashtable是线程安全的，它不能使用空值（null）作为key和value。</p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#84zee4').fadeToggle(100);"><p><strong>题干=</strong></p><p>HashSet与HashMap的比较<br/></p></div><div id="84zee4" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>HashSet是通过HashMap实现的, TreeSet是通过TreeMap实现的, 只不过Set用的只是Map的key。</p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#hvazbx').fadeToggle(100);"><p><strong>题干=</strong></p><p>谈谈WeakHashMap</p></div><div id="hvazbx" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>在实际开发中，WeakHashMap用得很少。WeakHashMap在某个关键字不再被引用的时候，会自动删除该关键字对应的Entry，以便被gc回收。</p><p>比如，</p><p>Object c = new Car();</p><p>c=null;</p><p>对于简单的情况, 手动置空是不需要程序员来做的, 因为在java中, 对于简单对象, 当调用它的方法执行完毕后, 指向它的引用会被从stack中popup, 所以他就能在下一次GC执行时被回收。但是, 也有特殊例外，当使用cache的时候，由于cache的对象正是程序运行需要的, 那么只要程序正在运行, cache中的引用就不会被GC给清除，那么随着cache中的reference越来越多, GC无法回收的object也越来越多，无法被自动回收. 通常的做法：当cache中的object需要被回收时, 回收这些object的任务只有交给编程者了。</p><p>如果使用WeakHashMap做cache，则当对象不被使用时，在gc的时候能够被回收（回收时机由jvm决定）。</p><p>参见：<a href="http://puretech.iteye.com/blog/2008663">http://puretech.iteye.com/blog/2008663</a></p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#8yz33v').fadeToggle(100);"><p><strong>题干=</strong></p><p>有没有WeakHashSet，如果没有，那么怎么解决Set情况下的弱引用对象缓存？</p></div><div id="8yz33v" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>没有WeakHashSet，但可以简单实现，JDK文档里面有例子和介绍：http://docs.oracle.com/javase/6/docs/api/java/util/Collections.html#newSetFromMap(java.util.Map)</p><pre class="brush:java;toolbar:false">Set&lt;Object&gt;&nbsp;weakHashSet&nbsp;=&nbsp;Collections.newSetFromMap(new&nbsp;WeakHashMap&lt;Object,&nbsp;Boolean&gt;());</pre><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#x3ve6c').fadeToggle(100);"><p><strong>题干=</strong></p><p>我们能否让HashMap同步？</p></div><div id="x3ve6c" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>HashMap可以通过下面的语句进行同步：</p><p>Map m = Collections.synchronizeMap(hashMap);</p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#y7xnav').fadeToggle(100);"><p><strong>题干=</strong></p><p>ConcurrentHashMap的并发度是什么?</p></div><div id="y7xnav" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>在JDK 1.6中，ConcurrentHashMap是采用分离锁的方式，它并没有对整个hash表进行锁定，而是局部锁定，也就是说当一个线程占有这个局部锁时，不影响其他线程对hash表其他地方的访问。</p><p>ConcurrentHashMap的并发度就是segment（分段）的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？</p><p>注意：在JDK 1.8中，ConcurrentHashMap不再使用Segment分离锁，而是采用一种乐观锁CAS算法来实现同步问题，但其底层还是“数组+链表-&gt;红黑树”的实现）。</p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#xg99zx').fadeToggle(100);"><p><strong>题干=</strong></p><p>JDK1.8的HashMap实现方式</p></div><div id="xg99zx" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>如下图</p><p><img src="{{site.assets_url}}img/20180429/1525006872234061274.jpg" title="1525006872234061274.jpg" alt="jdk18_hashmap.jpg"/></p><p>在之前的版本中，HashMap采用<strong>数组+链表</strong>实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当链表中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，HashMap采用<strong>数组+链表+红黑树</strong>实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p><p>允许null值的key，null key总是存放在Entry[]数组的第一个元素。关于Hash算法，当元素达到一定程度（根据装载因子来设定）会进行re-hash，另外如何计算hash值也有一定技巧。</p><p style='line-height: 1;'><br/></p><p>简单的讲：<span style="text-decoration: underline;"><em>HashMap是基于哈希表的Map接口的非同步实现，继承自AbstractMap，内部采用数组+链表+红黑树(jdk 1.8+)实现，通过计算key的hash值来确定元素在数组中的链表位置，再通过遍历链表查找元素的具体位置，而JDK1.8中，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</em></span></p><p>红黑树参考资料： 史上最清晰的红黑树讲解&nbsp;<a href="http://www.cnblogs.com/CarpenterLee/p/5503882.html" style="background-color: rgb(245, 245, 213);">http://www.cnblogs.com/CarpenterLee/p/5503882.html</a></p><p style='line-height: 1;'><br/></p></div>
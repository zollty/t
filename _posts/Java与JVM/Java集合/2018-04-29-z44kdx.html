---
layout: post
publishTime: 2018-04-29
category: Java与JVM
tags: Java集合
---

<div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#kcy75v').fadeToggle(100);"><p><strong>题干=</strong></p><p>ArrayList和LinkedList的比较</p></div><div id="kcy75v" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>ArrayList的内部实现是基于内部数组Object[],所以从概念上讲,它更象数组，但LinkedList的内部实现是基于一组连接的记录，所以，它更象一个链表结构，所以，它们在性能上有很大的差别：</p><p>在ArrayList的前面或中间插入数据时,你必须将其后的所有数据相应的后移,这样必然要花费较多时间，所以,当你的操作是在一列数据的后面添加数据而不是在前面或中间,并且需要随机地访问其中的元素时,使用ArrayList会提供比较好的性能； 而访问链表中的某个元素时,就必须从链表的一端开始沿着连接方向一个一个元素地去查找,直到找到所需的元素为止，所以,当你的操作是在一列数据的前面或中间添加或删除数据，并且按照顺序访问其中的元素时，就应该使用LinkedList了。</p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#8zcbe3').fadeToggle(100);"><p><strong>题干=</strong></p><p>ArrayList、Vector、CopyOnWriteArrayList的比较</p></div><div id="8zcbe3" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>Vector类是Java早期的一个类，在Java 1.2后，这两个类都继承自AbstractList抽象类，并实现了List接口。ArrayList是非线程安全的，而Vector使用了synchronized，是线程安全的，也因此，在单线程环境下Vector的效率比ArrayList要低。当Vector或ArrayList中的元素超过它的初始大小时,Vector会将它的容量翻倍,而ArrayList只增加50%的大小，这样,ArrayList就有利于节约内存空间。</p><p>CopyOnWriteArrayList采用了独特的Copy On Write方式，在兼顾了线程安全的同时，又提高了并发性。但它并不是像ConcurrentHashMap那样，是一个通用的并发集合。它只适合读多写少的地方使用，比如用来做缓存，读得多，但每天只更新一次。</p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#kxza3b').fadeToggle(100);"><p><strong>题干=</strong></p><p>说说CopyOnWriteArrayList的特点和应用场景？</p></div><div id="kxza3b" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>适合读多写少的场景，读的时候不加锁，写的时候先拷贝出一个副本，在副本上改动，写完之后用副本整个替换原来的引用。也因此写的时候比较耗内存，要考虑是否内存溢出。</p><p style='line-height: 1;'><br/></p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#vxav74').fadeToggle(100);"><p><strong>题干=</strong></p><p>为什么java.util.concurrent 包里没有并发的ArrayList实现？</p></div><div id="vxav74" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>JDK 5在java.util.concurrent里引入了ConcurrentHashMap，在需要支持高并发的场景，我们可以使用它代替HashMap。但是为什么没有ArrayList的并发实现呢？难道在多线程场景下我们只有Vector这一种线程安全的数组实现可以选择么？为什么在java.util.concurrent 没有一个类可以代替Vector呢？</p><p>答：我认为在java.util.concurrent包中没有加入并发的ArrayList实现的主要原因是：很难去开发一个通用并且没有并发瓶颈的线程安全的List。</p><p>像ConcurrentHashMap这样的类的真正价值（The real point / value of classes）并不是它们保证了线程安全。而在于它们在保证线程安全的同时不存在并发瓶颈。举个例子，ConcurrentHashMap采用了锁分段技术和弱一致性的Map迭代器去规避并发瓶颈。</p><p>所以问题在于，像“Array List”这样的数据结构，你不知道如何去规避并发的瓶颈。拿contains() 这样一个操作来说，当你进行搜索的时候如何避免锁住整个list？</p><p>另一方面，Queue 和Deque (基于Linked List)有并发的实现是因为他们的接口相比List的接口有更多的限制，这些限制使得实现并发成为可能。</p><p>CopyOnWriteArrayList是一个有趣的例子，它规避了只读操作（如get/contains）并发的瓶颈，但是它为了做到这点，在修改操作中做了很多工作和修改可见性规则。 此外，修改操作还会锁住整个List，因此这也是一个并发瓶颈。所以从理论上来说，CopyOnWriteArrayList并不算是一个通用的并发List。</p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#vav93y').fadeToggle(100);"><p><strong>题干=</strong></p><p>HashMap遍历时remove报ConcurrentModificationException异常是什么原因？</p></div><div id="vav93y" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>多线程并发操作集合时，当一些线程正在遍历集合的时候，另一些线程在remove集合的元素，这种情况下，next和remove方法就会因为元素个数的不一致导致ConcurrentModificationException异常。</p><p style='line-height: 1;'><br/></p></div><div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#zkc39k').fadeToggle(100);"><p><strong>题干=</strong></p><p>你了解JDK集合中的Fail-Fast机制吗？</p></div><div id="zkc39k" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>Fail-Fast即我们常说的快速失败,更多内容参看：</p><p><a href="http://blog.csdn.net/chenssy/article/details/38151189">http://blog.csdn.net/chenssy/article/details/38151189</a></p><p style='line-height: 1;'><br/></p></div>
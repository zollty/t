---
layout: post
publishTime: 2018-11-23
category: 算法与设计
tags: 数据结构
---

<div style="border:1px solid #3c763d; padding:0 8px; margin:0 -8px;" onclick="$('#vvcy99').fadeToggle(100);"><p><strong>题干=</strong></p><p>有没有学习过数据结构？请简单总结一下数据结构的基础知识？</p><p>什么是树结构，树的高度或深度是什么意思？</p><p>什么是堆结构，它有哪些特点？</p><p>有哪些常用的树形结构？提示：比如“二叉树”算一种。</p></div><div id="vvcy99" style="display:none;border:1px solid #317090; border-top-color:#aabaaa; padding:0 8px; margin:0 -4px;"><p><strong>答案=</strong></p><p>常见的数据结构有：</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>Linked List</p></li><li><p>Stack、Queue</p></li><li><p>Tree、Binary Tree、Binary Search Tree、AVL树、红黑树、Heap</p></li><li><p>Hashing</p></li><li><p>Graph</p></li></ul><p style='line-height: 1;'><br/></p><p>1、链表即是由节点（Node）组成的线性集合，每个节点可以利用指针指向其他节点。它是一种包含了多个节点的、能够用于表示序列的数据结构。</p><p><strong>单向链表</strong>: 链表中的节点仅指向下一个节点，并且最后一个节点指向空。</p><p><strong>双向链表</strong>: 其中每个节点具有两个指针 p、n，使得 p 指向先前节点并且 n 指向下一个节点；最后一个节点的 n 指针指向 null。</p><p><strong>循环链表</strong>：每个节点指向下一个节点并且最后一个节点指向第一个节点的链表。</p><p>时间复杂度:</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>索引: O(n)</p></li><li><p>搜索: O(n)</p></li><li><p>插入: O(1)</p></li><li><p>移除: O(1)</p></li></ul><p style='line-height: 1;'><br/></p><p>2、栈是元素的集合，其包含了两个基本操作：push 操作可以用于将元素压入栈，pop 操作可以将栈顶元素移除。</p><p>遵循<strong>后入先出原则（LIFO）</strong>。</p><p>时间复杂度:</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>索引: O(n)</p></li><li><p>搜索: O(n)</p></li><li><p>插入: O(1)</p></li><li><p>移除: O(1)</p></li></ul><p style='line-height: 1;'><br/></p><p>3、队列是元素的集合，其包含了两个基本操作：enqueue 操作可以用于将元素插入到队列中，而 dequeue 操作则是将元素从队列中移除。</p><p>遵循<strong>先入先出原则 (FIFO)</strong>。</p><p>时间复杂度:</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>索引: O(n)</p></li><li><p>搜索: O(n)</p></li><li><p>插入: O(1)</p></li><li><p>移除: O(1)</p></li></ul><p style='line-height: 1;'><br/></p><p>4、树状图是一种数据结构，它是由n（n&gt;=1）个有限结点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</p><p>它具有以下的特点：</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>每个结点有零个或多个子结点；</p></li><li><p>没有父结点的结点称为根结点；</p></li><li><p>每一个非根结点有且只有一个父结点；</p></li><li><p>除了根结点外，每个子结点可以分为多个不相交的子树。</p></li></ul><p style='line-height: 1;'><br/></p><p>5、各种类型的树</p><p style='line-height: 1;'><br/></p><p>有序树：树中任意节点的子结点之间有顺序关系，这种树称为有序树；</p><p style='line-height: 1;'><br/></p><p>二叉树：每个节点最多含有两个子树的树称为二叉树；</p><p style='line-height: 1;'><br/></p><p>完全二叉树 ：除最后一层外，每一层上的结点数均达到最大值；在最后一层上只缺少右边的若干结点。</p><p>特点：</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>对任一结点，如果其右子树的深度为j，则其左子树的深度必为j或j+1。</p></li><li><p>完全二叉树第i层至多有2^（i-1）个节点</p></li><li><p>对于tree[i]节点：</p></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;（1）若i为奇数且i&gt;1，那么tree的左兄弟为tree[i-1]；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;（2）若i为偶数且i&lt;n，那么tree的右兄弟为tree[i+1]；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;（3）若i&gt;1，tree的父亲节点为tree[i div 2]；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;（4）若2*i&lt;=n，那么tree的左孩子为tree[2*i]；若2*i+1&lt;=n，那么tree的右孩子为tree[2*i+1]；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;（5）若i&gt;n div 2,那么tree[i]为叶子结点（对应于（3））；</p><p style='line-height: 1;'><br/></p><p>平衡二叉树：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p style='line-height: 1;'><br/></p><p>霍夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树；</p><p style='line-height: 1;'><br/></p><p>6、二叉搜索树（BST）又称二叉 排序树，是一种特殊的二叉树，其任何节点中的值都会大于等于其左子树中存储的值并且小于等于其右子树中存储的值。（右边大，左边小）</p><p>特点和应用：中序遍历二叉排序树可得到一个关键字的有序序列，一个无序序列可以通过构造一棵二叉排序树变成一个有序序列，构造树的过程即为对无序序列进行排序的过程。</p><p style='line-height: 1;'><br/></p><p>进行插入操作时，不必移动其它结点，只需改动某个结点的指针即可。搜索、插入、,删除的复杂度等于树高：O(log(n))，</p><p>即时间复杂度:</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>索引: O(log(n))</p></li><li><p>搜索: O(log(n))</p></li><li><p>插入: O(log(n))</p></li><li><p>删除: O(log(n))</p></li></ul><p style='line-height: 1;'><br/></p><p>二叉排序/搜索树，最常用的是 <strong>平衡二叉搜索树</strong>（又称AVL树-来源于其发明者的名字），也就是说在 二叉排序树的基础上，增加了平衡二叉树的特点，这样的树结构非常适合做搜索，所以又叫做 平衡二叉搜索树。还有就是 <strong>红黑树</strong>。红黑树和AVL树的区别在于，红黑树并不追求“完全平衡”，但是任何不平衡都会在三次旋转之内解决。<span style="text-decoration: underline;">红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高</span>。红黑树是一个更高效的检索二叉树，典型地，JDK 提供的TreeMap就用了红黑树来实现。</p><p style='line-height: 1;'><br/></p><p>7、堆是一种特殊的基于完全二叉树的数据结构，整个堆中的所有父子节点的键值都会满足相同的排序条件。堆更准确地可以分为最大堆与最小堆，在最大堆中，父节点的键值永远大于或者等于子节点的值，并且整个堆中的最大值存储于根节点；而最小堆中，父节点的键值永远小于或者等于其子节点的键值，并且整个堆中的最小值存储于根节点。</p><p>时间复杂度:</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>访问最大值 / 最小值: O(1)</p></li><li><p>插入: O(log(n))</p></li><li><p>移除最大值 / 最小值: O(log(n))</p></li></ul><p style='line-height: 1;'><br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>堆和二叉排序树的区别</strong>在于：<br/></p><ol class=" list-paddingleft-2" style="list-style-type: decimal;"><li><p>在二叉排序树中，某结点的右孩子结点的值一定大于该结点的左孩子结点的值；在堆中却不一定，堆只限定了大小关系，但是可能是大于，也可以是小于。</p></li><li><p>在二叉排序树中，最小值结点是最左下结点，其左指针为空；最大值结点是最右下结点，其右指针为空。在大根堆中，最小值结点位于某个叶子结点，而最大值结点是大根堆的堆顶（即根结点）。</p></li><li><p>堆限定为是完全二叉树，具有n个结点的堆，其深度即为堆所对应的完全二叉树的深度log n 。而二叉排序树不一定是完全二叉树，具有n个结点的二叉排序树，最好情况下其深度为log n（表示以2为底的对数），最坏情况下其深度为n。</p></li></ol><p style='line-height: 1;'><br/></p><p>8、哈希表/散列表（Hash table），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;哈希表的主要思想是通过一个哈希函数，在所有可能的键与槽位（或者叫桶）之间建立一张映射表。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;最典型的的例子就是字典，如果我想要获取“按”字详细信息，我肯定会去根据拼音an去查找 拼音索引（或偏旁索引），我们首先去查an在字典的位置，查到“安”在第4页，这个页码就是哈希值。如果做成程序，就是传入一个关键码值，就能直接返回哈希值，查找的时间复杂度是常量级的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;哈希函数可能会遇到一种情况：两个值的哈希码算出来一样，那么它们会被散列到一个相同的槽位，这种就形成了哈希冲突/碰撞。上面字典的例子就是这样，第4页不止“安”一个字，可能有多个字在同一页。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;解决Hash碰撞的方法</p><ol class=" list-paddingleft-2" style="list-style-type: decimal;"><li><p>链地址法（Separate Chaining）: 链地址法中，每个桶是相互独立的，包含了一系列索引的列表。搜索操作的时间复杂度即是搜索桶的时间（固定时间）与遍历列表的时间之和。</p></li><li><p>开(放)地址法（Open Addressing）: 在开地址法中，当插入新值时，会判断该值对应的哈希桶是否存在，如果存在则根据某种算法依次选择下一个可能的位置，直到找到一个尚未被占用的地址。所谓开地址法也是指某个元素的位置并不永远由其哈希值决定。</p></li><li><p>建立一个公共溢出区：类似于开地址法，但是一旦有冲突，就直接选择放到公共溢出区中。</p></li></ol><p style='line-height: 1;'><br/></p><p>9、图是一种数据元素间为多对多关系的数据结构，加上一组基本操作构成的抽象数据类型。</p><p>&nbsp; &nbsp; &nbsp; 图是由顶点集合以及顶点间的关系集合组成的一种数据结构。</p><p>&nbsp; &nbsp; &nbsp; Graph = (V, E)&nbsp; &nbsp;V是<strong>顶点</strong>的有穷非空集合；E是顶点之间关系的有穷集合，也叫<strong>边</strong>集合。</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>无向图（Undirected Graph）: 无向图具有对称的邻接矩阵，因此如果存在某条从节点 u 到节点 v 的边，反之从 v 到 u 的边也存在。比如连接顶点A与D的边，可以表示为无序对(A,D)，也可以写成(D,A)。</p></li><li><p>有向图（Directed Graph）: 有向图的邻接矩阵是非对称的，即如果存在从 u 到 v 的边并不意味着一定存在从 v 到 u 的边。与无向图不同，连接顶点A到D的有向边称为弧，A是弧尾，D是弧头，&lt;A,D&gt;表示弧，注意不能写成&lt;D,A&gt;。</p></li><li><p>如果对于图中任意两个顶点都是连通的，则成G是连通图。</p></li><li><p>有向的连通图称为强连通图。<br/></p></li><li><p>图中顶点之间有邻接点。无向图顶点的边数叫做度。有向图顶点分为入度和出度。</p></li><li><p>图上的边和弧上带权则称为网。</p></li></ul><p style='line-height: 1;'><br/></p><p>（1） 邻接矩阵</p><p>图的邻接矩阵存储方式是用两个数组来表示图：</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>一个<span style="text-decoration: underline;">一维数组</span>存储图中<span style="text-decoration: underline;">顶点</span>信息；</p></li><li><p>一个<span style="text-decoration: underline;">二维数组</span>（称为邻接矩阵）存储图中<span style="text-decoration: underline;">边或弧</span>的信息。</p><p>例如，顶点集合V={A,B,C,D}；边集合E={(A,B),(B,C),(C,D),(D,A),(A,C)}（弧用&lt;A,D&gt;表示）</p></li></ul><p style='line-height: 1;'><br/></p><p>（2）邻接表</p><p>邻接矩阵是一种不错的图存储结构。 但是：对于边树相对顶点较少的图，这种结构是存在存储空间的极大浪费的。</p><p>因此我们考虑先进一步，使用邻接表存储，其实邻接表就是用链表和指针来代替邻接矩阵的一、二维数组。<br/></p><p style='line-height: 1;'><br/></p><p>图的应用：常见的是 求两点的最短路径，或者加权最短路径，还有就是查找搜索算法——深度优先、广度优先。</p><p style='line-height: 1;'><br/></p><p>图的参考资料：<a href="https://www.cnblogs.com/Braveliu/p/3455442.html">https://www.cnblogs.com/Braveliu/p/3455442.html</a> </p><p style='line-height: 1;'><br/></p></div>
<p>题干=</p><p>Java代码的编译过程？</p><p>答案=<br/></p><p><strong>源代码</strong>---词法分析---语法分析---语义分析---字节码生成器---<strong>字节码</strong></p><p><br/></p><p><strong>题干=</strong></p><p>Java Class文件的加载过程？</p><p>ClassLoader的加载顺序是怎样？</p><p><strong>答案=</strong></p><p><strong>1、将类装入JVM中</strong></p><p>在Java中，类装载器把一个类装入JVM中，要经过以下步骤：</p><p>&nbsp; &nbsp; &nbsp;(1) 装载：查找和导入Class文件；</p><p>&nbsp; &nbsp; &nbsp;(2) 链接：把类的二进制数据合并到JRE中；</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;校验：检查载入Class文件数据的正确性；</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;准备：给类的静态变量分配存储空间；</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;解析：将符号引用转成直接引用；</p><p>&nbsp; &nbsp; &nbsp;(3) 初始化：对类的静态变量，静态代码块执行初始化操作</p><p><strong>2、通过ClassLoader加载类</strong></p><ol class="custom_num2 list-paddingleft-1"><li class="list-num-3-1 list-num2-paddingleft-1"><p>Bootstrap ClassLoader</p><p>负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类</p></li><li class="list-num-3-2 list-num2-paddingleft-1"><p>Extension ClassLoader</p><p>负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包</p></li><li class="list-num-3-3 list-num2-paddingleft-1"><p>App ClassLoader</p><p>负责记载classpath中指定的jar包及目录中class</p></li><li class="list-num-3-4 list-num2-paddingleft-1"><p>Custom ClassLoader</p><p>属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader</p></li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;加载过程中会先检查类是否被已加载，<strong>检查顺序是自底向上</strong>，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而<strong>加载的顺序是自顶向下</strong>，也就是由上层来逐层尝试加载此类。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;另外，热点方法的字节码，可能会被JIT编译器(Just-in-time Compiler) 编译成本地目标代码，如下：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;字节码 ---&gt; JIT Compiler 即时编译 ---&gt; 对应操作系统的目标代码</p><p><br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;参见：<a href="https://blog.csdn.net/javazejian/article/details/73413292/">https://blog.csdn.net/javazejian/article/details/73413292/</a></p><p>&nbsp; &nbsp;</p><p><strong>题干=</strong></p><p>什么是类加载的双亲委派模式，可以打破这种模式吗？</p><p>类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？</p><p><strong>答案=</strong><br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;双亲委派模式：如果一个类加载器收到了&nbsp;类加载的请求，那么它首先不会自己去尝试加载这个类，而是将这个请求委派给自己的父加载器去完成，每一层的加载器都是，因此任何一个加载请求都会自动传送到顶层的启动类加载器中，只有当自己的父加载器反馈无法完成这个加载请求的时候，子加载器才会去尝试自己去加载。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;可以打破这种模式，Web服务器Tomcat、WebSphere等都自定义了自己的WebAppClassLoader（没有继承自AppClassLoader），<span style="text-decoration: underline;">以便在同一个服务器下运行的多个APP代码、jar包能相互隔离</span>，APP1无法调用到APP2的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>双亲委派模式的好处：</strong><br/></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>主要是为了安全性，避免用户自己编写的类动态替换 Java 的一些核心类，比如 String；</p></li><li><p>同时也避免了重复加载，因为 JVM 中区分不同类，不仅仅是根据类名，相同的 class 文件被不同的 ClassLoader 加载就是不同的两个类。</p></li></ul><p><br/></p><p>题干=</p><p>类的实例化顺序？</p><p>答案=</p><p>对象初始化的顺序，<span style="text-decoration: underline;">先静态方法，再构造方法，每个又是先基类后子类</span>。</p><p>如下所示：</p><ol class=" list-paddingleft-2" style="list-style-type: decimal;"><li><p>父类静态成员和静态初始化块 ，按在代码中出现的顺序依次执行</p></li><li><p>子类静态成员和静态初始化块 ，按在代码中出现的顺序依次执行</p></li><li><p>父类实例成员和实例初始化块 ，按在代码中出现的顺序依次执行</p></li><li><p>父类构造方法</p></li><li><p>子类实例成员和实例初始化块 ，按在代码中出现的顺序依次执行</p></li><li><p>子类构造方法</p></li></ol><p><br/></p><p>题干=</p><p>Class文件结构</p><p>答案=</p><p>xxx</p><p><br/></p><p>题干=</p><p>一个对象的内存划分是怎样的？</p><p>答案=</p><p>可分为3块区域：对象头，实例数据，对齐填充。</p><p>（1）对象头由Mark world和类型指针组成</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mark World包括hash码，GC分代年龄，锁状态标志等。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;类型指针来确定这个对象是哪个类的实例</p><p>（2）实例数据是对象存储的真正的有效信息</p><p>（3）hostspot虚拟机要求对象的大小必须是8字节的整数倍</p><p><br/></p><p>题干=<br/></p><p>请描述一下Java 对象的创建过程。</p><p>答案=</p><p>&nbsp;&nbsp;&nbsp;&nbsp;1. 类加载检查： 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;2. 分配内存： 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;3. 初始化零值： 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;4. 设置对象头： 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;5. 执行 init 方法： 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，&lt;init&gt; 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 &lt;init&gt; 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><p><br/></p><p>内存分配并发问题（补充内容，需要掌握）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</p></li><li><p>TLAB： 为每一个线程预先在 Eden 区分配一块内存。JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配。</p></li></ul><p><br/></p><p>题干=</p><p>java中init和clinit方法</p><p>答案=</p><p>xxx</p><p><br/></p><p>题干=</p><p>对象的访问定位的两种方式（句柄和直接指针两种方式）</p><p>答案=</p><p>&nbsp;&nbsp;&nbsp;&nbsp;建立对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有使用句柄和直接指针两种：</p><ol class=" list-paddingleft-2" style="list-style-type: decimal;"><li><p>句柄： 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p></li><li><p>直接指针： 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。</p></li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p><p><br/></p><p>题干=<br/></p><p>判断对象存活的算法？（GC对象的判定方法)</p><p>在Java中，对象什么时候可以被垃圾回收？</p><p>简述可达性分析算法</p><p>答案=</p><p>（1）引用计数法：给对象添加一个引用计数器，每当有一个地方引用它，引用计数器值加1，否则减1，为0时不能再被使用</p><p>（2）可达性分析法：到GC Root可达，则为不可被回收的对象</p><p>&nbsp; （GC Root：虚拟机栈，本地方法栈，方法区静态属性，方法区常量所引用的对象）</p><p><br/></p><p>GC的两种判定方法：引用计数与引用链。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;1.在JDK1.2之前，使用的是引用计数器算法，即当这个类被加载到内存之后，就会产生方法区，堆栈、程序计数器等一系列信息，当创建对象的时候，为这个对象在堆栈空间中分配对象，同时会产生一个引用计数器，同时引用计数器+1，当有新的引用时，引用计数器继续+1，而当其中一个引用销毁时，引用计数器-1，当引用计数器减为0的时候，标志着这个对象已经没有引用了，可以回收了！但是这样会有一个问题：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;当我们的代码出现这样的情况时：</p><p>a)ObjA.obj=ObjB</p><p>b)ObjB.obj=ObjA</p><p>&nbsp;&nbsp;&nbsp;&nbsp;这样的代码会产生如下引用情形objA指向objB，而ObjB又指向objA，这样当其他所有的引用都消失了之后，objA和objB还有一个相互的引用，也就是说两个对象的引用计数器各为1，而实际上这两个对象都已经没有额外的引用，已经是垃圾了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;2.根搜索算法：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;根搜索算法是从离散数学中的图论引入的，程序把所有的引用关系看做一张图，从一个节点GC Root开始，寻找对应的引用节点，找到这个节点之后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被饮用到的节点，即无用的节点。<br/></p><p>&nbsp;&nbsp;&nbsp;&nbsp;目前Java中可作为GC Root的对象有：</p><ol class=" list-paddingleft-2" style="list-style-type: decimal;"><li><p>虚拟机栈中引用的对象（本地变量表）</p></li><li><p>方法区中静态属性引用的对象</p></li><li><p>方法区中常量引用的对象</p></li><li><p>本地方法栈中引用的对象(Native对象)。</p></li></ol><p>参见：<a href="https://blog.csdn.net/luzhensmart/article/details/81431212" target="_blank">https://blog.csdn.net/luzhensmart/article/details/81431212</a></p><p><br/></p><p>题干=</p><p>java中存在的四种引用以及它们和gc之间的关系</p><p>答案=<br/></p><p>（1）强引用：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;只要引用存在，垃圾回收器永远不会回收。</p><p>（2）软引用</p><p>&nbsp;&nbsp;&nbsp;&nbsp;非必须引用，内存溢出之前进行回收，可以通过以下代码实现</p><pre class="brush:java;toolbar:false">Object&nbsp;obj=new&nbsp;Object();
SoftReference&lt;Object&gt;&nbsp;sf=newSoftRerence&lt;Object&gt;(obj);
obj=null;
sf.get();//有时会返回null</pre><p>&nbsp;&nbsp;&nbsp;&nbsp;这时候sf是对obj的一个软引用，通过sf.get()方法可以取到这个对象，当然这个对象被标记为需要回收的对象时，则返回null；软引用主要用于用户实现类似缓存的功能，在内存不足的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真实的来源查询这些数据。</p><p>（3）弱引用</p><p>&nbsp;&nbsp;&nbsp;&nbsp;第二次垃圾回收时回收，可以通过如下代码实现</p><pre class="brush:java;toolbar:false">Object&nbsp;obj=new&nbsp;Object();
WeakReference&lt;Object&gt;&nbsp;wf=newWeakReference&lt;Object&gt;(obj);
obj=null;
wf.get();//有时会返回null
wf.isEnQueued();//返回是否被垃圾回收器标记为即将回收的垃圾</pre><p>&nbsp;&nbsp;&nbsp;&nbsp;弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。弱引用主要用于监控对象是否已经被标记为即将回收的垃圾，可以通过弱引用的isEnQueues方法返回对象是否被垃圾回收器标记。</p><p>（4）虚引用</p><p>&nbsp;&nbsp;&nbsp;&nbsp;垃圾回收时回收，无法通过引用取到对象值，可以通过如下代码实现</p><pre class="brush:java;toolbar:false">Object&nbsp;obj=new&nbsp;Object();
PhantomReference&lt;Object&gt;&nbsp;pf=newPhantomReference&lt;Object&gt;(obj);
obj=null;
pf.get();//永远是返回null
pf.isEnQueued();//返回从内从中已经删除。</pre><p>&nbsp;&nbsp;&nbsp;&nbsp;虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null。</p><p><br/></p><p>题干=</p><p>Java方法的静态绑定与动态绑定(向上转型的运行机制）</p><p>答案=</p><p>参见：<a href="https://www.cnblogs.com/ygj0930/p/6554103.html">https://www.cnblogs.com/ygj0930/p/6554103.html</a> </p><p><br/></p><p>题干=</p><p>Java多态性实现机制——静态分派与动态分派</p><p>答案=</p><p>参见：<a href="https://blog.csdn.net/ma15732625261/article/details/81236370">https://blog.csdn.net/ma15732625261/article/details/81236370</a> </p><p><a href="https://blog.csdn.net/qq_40695597/article/details/81053195">https://blog.csdn.net/qq_40695597/article/details/81053195</a> </p><p><br/></p><p>题干=</p><p>JVM的逃逸分析技术</p><p>答案=</p><p>参见：<a href="https://www.cnblogs.com/chenglc/p/9327700.html">https://www.cnblogs.com/chenglc/p/9327700.html</a></p><p><a href="https://blog.csdn.net/w372426096/article/details/80938788">https://blog.csdn.net/w372426096/article/details/80938788</a> </p><p><a href="https://blog.csdn.net/baichoufei90/article/details/85180478">https://blog.csdn.net/baichoufei90/article/details/85180478</a> </p><p><br/></p><p>题干=</p><p>java中子类有没有继承父类的私有变量？</p><p>java中，创建子类对象时，父类对象会也被一起创建么？</p><p>答案=</p><p>如下：</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>从继承的概念来说，private和final不被继承。Java官方文档上是这么说的。</p></li><li><p>从内存的角度来说，父类的一切都被继承(从父类构造方法被调用就知道了，因为new一个对象，就会调用构造方法，子类被new的时候就会调用父类的构造方法，所以从内存的角度来说，子类拥有一个完整的父类)。子类对象所引用的内存有父类变量的一份拷贝。</p></li><li><p>访问父类的构造函数并不意味这创建了父类的实例，子类的实例化只会产生子类的实例。</p></li><li><p>父类中私有成员也会被继承，但是子类没有直接访问权限（子类访问父类私有成员的时候编译报错信息是”private access”，而不是不存在）。</p></li></ul><p>参见：<a href="http://www.yuhangma.com/2019/java/2019-04-28-object-initialize/">http://www.yuhangma.com/2019/java/2019-04-28-object-initialize/</a> </p><p><br/></p><p>题干=</p><p>Java中finalize方法的作用</p><p>答案=</p><p>参见：</p><p><a href="https://www.cnblogs.com/smilesmile/p/3849122.html">https://www.cnblogs.com/smilesmile/p/3849122.html</a> </p><p><a href="https://www.cnblogs.com/Smina/p/7189427.html">https://www.cnblogs.com/Smina/p/7189427.html</a> </p><p><br/></p><p><br/></p><p><br/></p>
<p><strong>题干=</strong><br/></p><p>SynchronousQueue的应用场景，以及和size=1的ArrayBlockingQueue的区别</p><p><strong>答案=</strong></p><p>不像ArrayBlockingQueue或LinkedListBlockingQueue，SynchronousQueue内部并没有数据缓存空间，你不能调用peek()方法来看队列中是否有数据元素，当然遍历这个队列的操作也是不允许的。实际上，队列头元素是第一个排队要插入数据的线程，而不是要交换的数据。数据是在配对的生产者和消费者线程之间直接传递的，并不会将数据缓冲数据到队列中。可以这样来理解：生产者和消费者互相等待对方，握手，然后一起离开。</p><p><br/></p><p>SynchronousQueue特点：生产完立即触发消费，队列中不会有任何缓存，SynchronousQueue只是一个协调者。</p><p>如果使用size=1的ArrayBlockingQueue也能实现，但是队列中可能有1个堆积：假设生产者速度很快，生产了3个，试图往队列里面放，但是消费者处理慢，只能取走一个处理，此时队列里面就会有一个堆积，剩下一个没有在队列里，处于阻塞状态。如果是SynchronousQueue，那么第1个被取走处理，剩下2个都会处于阻塞状态，队列里面没有数据。</p><p><br/></p><p>所以，SynchronousQueue的应用场景就是，以消费者为中心，异步执行一个任务，任务没有执行完时，其他所有待执行任务都阻塞。其实这样看来，SynchronousQueue和size=1的ArrayBlockingQueue区别也不大，但是SynchronousQueue性能可能会好一些。</p><p>参考资料：<a href="https://blog.csdn.net/aitangyong/article/details/38684831">https://blog.csdn.net/aitangyong/article/details/38684831</a> </p><p><br/></p><p>例如Java Executors提供的线程池类型newCachedThreadPool，就用了SynchronousQueue，创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。</p><p>怎么理解呢？创建的新线程，用完后会成为SynchronousQueue的生产者，试图往队列里面添加线程，添加新任务相当于消费者，会首先从SynchronousQueue队列取线程。如果1秒钟新添加一个任务，每个任务执行1.9秒，执行过程如下：</p><p>00:01.0 第一个任务开始执行，创建新线程1...</p><p>00:02.0 第二个任务开始执行，创建新线程2...</p><p>00:02.9 第一个任务执行完，线程1进入队列、等待消费.</p><p>00:03.0 第三个任务开始执行，消费线程1...</p><p>00:03.9 第二个任务执行完，线程2进入队列、等待消费.</p><p>00:04.0 第四个任务开始执行，消费线程2...</p><p>00:04.9 第三个任务执行完，线程1进入队列、等待消费.</p><p>00:05.0 第五个任务开始执行，消费线程1...</p><p>可见，只创建了两个线程，有如下特点：所有新添加的任务都会立即执行，且所有执行任务的线程都会被及时复用、不会浪费。但是不适合执行时间长且执行频繁的任务，因为这样就会创建很多线程。</p><p><br/></p><p>这里，如果使用size=1的ArrayBlockingQueue代替SynchronousQueue来实现，也是可以的，执行过程几乎完全一样，两者效果差不多。</p><p><br/></p>
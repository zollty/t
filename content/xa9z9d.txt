<p><strong>题干=</strong><br/></p><p>谈一下你对工厂模式和单例模式的理解？</p><p><strong>答案=</strong></p><p><strong>工厂模式</strong>：英文名factory，使用非常广泛，其精髓就是通过一个工厂类来生成具有某些抽象相同点的实例对象。在我所做的数据筛选项目中，就使用了一个BeanFactory，将所有的数据信息传给BeanFactory，由工厂来加工，工厂根据数据的特点，找到加工的方法（建造者，此处结合了“建造者模式”），将数据处理完之后封装成一个统一的bean对象返回给调用者。这样做的好处在于，调用者无需关心每种数据的具体处理逻辑，只需要把数据交给工厂，工厂就能够按照标准，输出一个标准对象。</p><p><strong>单例模式</strong>：英文名singleton，使用非常广泛，单例模式又分为懒汉模式和饿汉模式，其中懒汉模式，即延迟加载，是在使用时才做初始化操作，而饿汉模式是在类加载的时候就做初始化。单例模式有很多种实现方式，我总结的高效可用的有DCL-volatile（Double Checked Locking，双重检查锁）方式，enumerate方式，inner-class方式。</p><p><br/></p><p><strong>题干=</strong></p><p>什么是装饰者模式、门面外观模式、代理模式和适配器模式？它们的区别是什么？</p><p><strong>答案=</strong></p><p><strong>装饰者模式</strong>：英文名decorate，对原有接口进行包装，对外提供包装过后的接口，又可以叫wrapper，java io里面的BufferReader、BufferWriter都是使用了这个模式。在我的开源项目jretty-log里面，其核心的log api设计就使用到了装饰者模式，在spring-securit里面做权限校验也采用了装饰者模式。</p><p><br/></p><p><strong>门面模式（或者外观模式）</strong>：英文名facade，有一款使用最广泛的log库，SLF4J就使用了门面模式，它是为了屏蔽各种底层的实现，对外提供一个统一的入口，所有操作都通过这个入口进行。就拿SLF4J来说，所有记日志，都只需要使用SLF4J提供的Logger和LoggerFactory就可以了，里面最终使用的日志记录的底层实现，可以使用各种日志库，比如log4j，logback。</p><p><br/></p><p><strong>代理模式</strong>：代理模式，跟装饰者模式有点容易混淆，装饰者模式不会改变被装饰者的逻辑，但是代理模式则有可能改变被代理者的逻辑。而且，代理模式通常是对象替换，把原来调用的对象，暗地里换成了重新生成的一个伪对象，使用者像使用原对象一样使用代理对象，而装饰者模式不会替换原有对象，要想使用装饰者，则必须显示的使用装饰者包装后的对象，比如FileInputStream，如果要用它的装饰者BufferReader，则必须显式的new BufferReader，而如果使用代理，则可以通过动态代理的方式偷天换日，把原对象替换成代理后的对象。</p><p><br/></p><p><strong>适配器模式</strong>：英文名adaptor，它的目的是解决兼容性问题，可以分为类的适配、接口的适配，它可以将旧的接口封装，以适应新的标准，也可以是基于某个标准，重新封装去适配另一个标准。</p><p>桥接模式：和门面模式有些像，门面模式是基于很多已有的实现（或者复杂的系统），提供一套统一的对外的接口，它是做大整合。桥接模式是做转换，将多种已有的实现转换成一套统一的接口。一个是做整合，一个是做转换。通常，桥接模式可以动态的接收多种需要做转换的类，将其转换成另一套接口使用，而门面模式在初始化时指定一种实现，然后基于这种实现提供服务。</p><p><br/></p>
<p>题干=<br/></p><p>结合Spring说一下AOP的原理和用途。</p><p><br/></p><p>题干=</p><p>Spring有哪几种方法可以执行自定义的Bean初始化和销毁方法？它们的执行顺序是什么？</p><p>（比如有一个Bean，我想让它在初始化的时候执行init方法，销毁时执行shutdown方法）</p><p>答案=</p><p>Bean初始化： Constructor -&gt; @PostConstruct -&gt; InitializingBean.afterPropertiesSet() -&gt; xml config init-method</p><p>Bean销毁： @PreDestroy -&gt; DisposableBean.destroy() -&gt; xml config destroy-method</p><p>参见：</p><p>As of Spring 2.5, Multiple lifecycle mechanisms configured for the same bean, with different initialization methods, are called as follows:</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>Methods annotated with&nbsp;<span style="color: rgb(192, 0, 0);"><strong>@PostConstruct</strong></span></p></li><li><p><strong><span style="color: rgb(192, 0, 0);">afterPropertiesSet()</span></strong>&nbsp;as defined by the&nbsp;<span style="color: rgb(192, 0, 0);"><strong>InitializingBean&nbsp;</strong></span>callback interface</p></li><li><p>A custom configured&nbsp;<span style="color: rgb(192, 0, 0);"><strong>init()</strong></span>&nbsp;method</p></li></ul><p>Destroy methods are called in the same order:</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>Methods annotated with&nbsp;<strong><span style="color: rgb(192, 0, 0);">@PreDestroy</span></strong></p></li><li><p><span style="color: rgb(192, 0, 0);"><strong>destroy()</strong></span>&nbsp;as defined by the&nbsp;<strong><span style="color: rgb(192, 0, 0);">DisposableBean&nbsp;</span></strong>callback interface</p></li><li><p>A custom configured&nbsp;<span style="color: rgb(192, 0, 0);"><strong>destroy()</strong></span>&nbsp;method</p></li></ul><p><br/></p><p>题干=</p><p>Spring支持事务的传播特性又有哪些？什么是嵌套事务？</p><p>分析=</p><p><a href="http://m.blog.csdn.net/article/details?id=14149137">http://m.blog.csdn.net/article/details?id=14149137</a></p><p><br/></p><p>题干=</p><p>Spring加载resource时classpath*:与classpath:的区别</p><p>答案=</p><p>网上的答案，基本上都是错误的，下面根据我的测试结果，澄清一下：</p><p><br/></p><p><strong>首先，弄清楚什么是classpath？</strong></p><p><br/></p><p>对于classpath作用的解释在《Thinking in Java》中有如下解释：</p><p>Java 解释器的工作程序如下：&nbsp;</p><p>首先，它找到环境变量CLASSPATH。CLASSPATH 包含了一个或多个目录，它们作为一种特殊的“根”使用，从这里展开对.class 文件的搜索。</p><p><br/></p><p>classpath是什么? 它的作用是什么？</p><p>classpath是javac编译器的一个环境变量。</p><p>它的作用是指定类搜索路径，它与import、package关键字有关。</p><p>当你写下improt java.util.*时，编译器面对import关键字时，就知道你要引入java.util这个package中的类；但是编译器如何知道你把这个package放在哪里了呢？所以你首先得告诉编译器这个package的所在位置；如何告诉它呢？就是设置CLASSPATH。</p><p>当你自己开发一个package时，然后想要用这个package中的类；自然，你也得把这个package所在的目录设置到CLASSPATH中去！</p><p><br/></p><p>可以看出，CLASSPATH 里能包含大量备用的搜索路径。然而，使用JAR 文件时要注意一个问题：必须将JAR文件的名字置于类路径里，而不仅仅是它所在的路径。所以对一个名为grape.jar 的JAR 文件来说，我们的类路径需要包括：<em>CLASSPATH=.;D:\JAVA \LIB;C:\flavors\grape.jar</em>，注意最前面的&quot;.;&quot; 这个是告诉JDK，搜索CLASS时先查找当前目录。</p><p><br/></p><p><strong>classpath和classpath*区别：&nbsp;</strong></p><p>&quot;classpath:&quot; 从所有classpath按顺序搜索，找到第一个符合条件的文件就返回。</p><p>&quot;classpath*:&quot; 从所有classpath按顺序搜索，找出所有符合条件的文件。</p><p>通俗一点说就是，classpath和classpath*都类似对所有classpath进行遍历，而前者找到文件就break，后者不会break，它会遍历完所有classpath。</p><p><br/></p><p>网上那些答案说，&quot;classpath:&quot;只从当前classes目录查找文件，不会查找jar包，是严重错误的，其实jar包也可能是一个classpath路径，我们可以在Eclipse的.classpath文件中查看到当前的classpath有那些，甚至可以调整其顺序。如下所示：</p><pre class="brush:xml;toolbar:false">&lt;?xml&nbsp;version=&quot;1.0&quot;&nbsp;encoding=&quot;UTF-8&quot;?&gt;
&lt;classpath&gt;
&nbsp;&nbsp;&lt;classpathentry&nbsp;kind=&quot;src&quot;&nbsp;output=&quot;target/classes&quot;&nbsp;path=&quot;src/main/java&quot;&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;attributes&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;attribute&nbsp;name=&quot;optional&quot;&nbsp;value=&quot;true&quot;&nbsp;/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;attribute&nbsp;name=&quot;maven.pomderived&quot;&nbsp;value=&quot;true&quot;&nbsp;/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/attributes&gt;
&nbsp;&nbsp;&lt;/classpathentry&gt;
&nbsp;&nbsp;&lt;classpathentry&nbsp;excluding=&quot;**&quot;&nbsp;kind=&quot;src&quot;&nbsp;output=&quot;target/classes&quot;&nbsp;path=&quot;src/main/resources&quot;&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;attributes&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;attribute&nbsp;name=&quot;maven.pomderived&quot;&nbsp;value=&quot;true&quot;&nbsp;/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/attributes&gt;
&nbsp;&nbsp;&lt;/classpathentry&gt;
&nbsp;&nbsp;&lt;classpathentry&nbsp;kind=&quot;src&quot;&nbsp;output=&quot;target/test-classes&quot;&nbsp;path=&quot;src/test/java&quot;&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;attributes&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;attribute&nbsp;name=&quot;optional&quot;&nbsp;value=&quot;true&quot;&nbsp;/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;attribute&nbsp;name=&quot;maven.pomderived&quot;&nbsp;value=&quot;true&quot;&nbsp;/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/attributes&gt;
&nbsp;&nbsp;&lt;/classpathentry&gt;
&nbsp;&nbsp;&lt;classpathentry&nbsp;kind=&quot;con&quot;&nbsp;path=&quot;.../JavaSE-1.6&quot;&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;attributes&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;attribute&nbsp;name=&quot;maven.pomderived&quot;&nbsp;value=&quot;true&quot;&nbsp;/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/attributes&gt;
&nbsp;&nbsp;&lt;/classpathentry&gt;
&nbsp;&nbsp;&lt;classpathentry&nbsp;kind=&quot;con&quot;&nbsp;path=&quot;org.eclipse.m2e.MAVEN2_CLASSPATH_CONTAINER&quot;&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;attributes&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;attribute&nbsp;name=&quot;maven.pomderived&quot;&nbsp;value=&quot;true&quot;&nbsp;/&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/attributes&gt;
&nbsp;&nbsp;&lt;/classpathentry&gt;
&nbsp;&nbsp;&lt;classpathentry&nbsp;kind=&quot;output&quot;&nbsp;path=&quot;target/classes&quot;&nbsp;/&gt;
&lt;/classpath&gt;</pre><p><br/></p><p><br/></p><p>题干=</p><p>Spring boot 配置加载的优先级？</p><p>答案=</p><p>类型的优先级如下：</p><p>&nbsp; &nbsp; a. 命令行参数</p><p>&nbsp; &nbsp; b. 来自java:comp/env的JNDI属性</p><p>&nbsp; &nbsp; c. Java系统属性（System.getProperties()）</p><p>&nbsp; &nbsp; d. 操作系统环境变量（System.env()）</p><p>&nbsp; &nbsp; e. RandomValuePropertySource配置的random.*属性值</p><p>&nbsp; &nbsp; f. jar外部的application-{profile}.properties或application.yml(带spring.profile)配置文件</p><p>&nbsp; &nbsp; g. jar内部的application-{profile}.properties或application.yml(带spring.profile)配置文件</p><p>&nbsp; &nbsp; h. jar外部的application.properties或application.yml(不带spring.profile)配置文件</p><p>&nbsp; &nbsp; i. jar内部的application.properties或application.yml(不带spring.profile)配置文件</p><p>&nbsp; &nbsp; j. @Configuration注解类上的@PropertySource</p><p>&nbsp; &nbsp; k. 通过SpringApplication.setDefaultProperties指定的默认属性</p><p>属性文件，按优先级排序，位置高的将覆盖位置低的&nbsp;</p><p>&nbsp; &nbsp; 1. 当前目录下的一个/config子目录&nbsp;</p><p>&nbsp; &nbsp; 2. 当前目录&nbsp;</p><p>&nbsp; &nbsp; 3. 一个classpath下的/config包&nbsp;</p><p>&nbsp; &nbsp; 4. classpath根路径（root）&nbsp;</p><p>如果 application.properties 和 application.yml 同时存在，则前者的优先级更高。</p><p><br/></p>
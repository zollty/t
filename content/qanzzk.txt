<p>题干=</p><p>Redis2和Redis3的区别，Redis3内部通讯机制？</p><p>答案=</p><p>最重要的区别是Redis3官方推出了redis cluster。</p><p>Redis3内部的通行机制，传输层是基于TCP协议通信（默认端口号是6379），应用层是基于redis自己定义的RESP序列化协议(REdis&nbsp;Serialization&nbsp;Protocol)（参见：<a href="https://redis.io/topics/protocol">https://redis.io/topics/protocol</a>）。</p><p><br/></p><p>题干=</p><p>Redis里面提到它支持存储二进制安全的字符串（Binary safe string），那么“二进制安全”代表什么意思？</p><p>答案=<br/></p><p>有一些特殊字符，它的二进制表示不是通用的，不同的语言、不同的程序处理，可能会得到不一样的结果。比如，byte里，有ASCII代码的字符，例如ABC...XYZ，123456789，也有一些特殊字符，例如回车，退格之类的，有些特殊字符是无法显示的，甚至没有定义的。例如编码65到哪儿都是字母A，编码97到哪儿都是字符a，退格在有的地方显示成一个符号，在有的地方就会真的把前一个字符退掉，而编码 -107 、-85 可能根本就没有定义。所以，如果把一串随机的二进制转换成字符串，它很可能含有许多特殊字符或者未定义的字符，那么它就不是二进制安全的。</p><p>附：一个例子，C的字符串里，一种经典的定义就是，以编码0作为字符串的结尾。那么，假设这样一个string，里面3个字符的编码分别是97，0，97。那么，C里面如果有str_replace等效的函数， 利用它把97换成98，那么这个函数读取到0的时候，就认为已经结束了，就会得到98，0，97。跟它对应的，PHP里的str_replace是二进制安全的，那么这个0不会被视为特殊的结束符号，于是结果就是98，0，<strong>98</strong>。</p><p><br/></p>
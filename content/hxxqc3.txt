<p><strong>题干=</strong></p><p>Android官方Guide</p><p>答案=</p><p>参见：<a href="https://developer.android.google.cn/guide/components/aidl" target="_blank">https://developer.android.google.cn/guide/components/aidl</a></p><p><strong><br/></strong></p><p><strong>题干=</strong></p><p>Android的四大组件是哪些，它们的作用？</p><p><strong>答案=</strong></p><p>Activity：Activity是Android程序与用户交互的窗口，是Android构造块中最基本的一种，它需要为保持各界面的状态，做很多持久化的事情，妥善管理生命周期以及一些跳转逻辑</p><p><br/></p><p>service：后台服务于Activity，封装有一个完整的功能逻辑实现，接受上层指令，完成相关的事物，定义好需要接受的Intent提供同步和异步的接口</p><p><br/></p><p>Content Provider：是Android提供的第三方应用数据的访问方案，可以派生Content Provider类，对外提供数据，可以像数据库一样进行选择排序，屏蔽内部数据的存储细节，向外提供统一的借口模型，大大简化上层应用，对数据的整合提供了更方便的途径</p><p><br/></p><p>BroadCast Receiver：接受一种或者多种Intent作触发事件，接受相关消息，做一些简单处理，转换成一条Notification，统一了Android的事件广播模型。</p><p><br/></p><p><strong>题干=</strong></p><p>简要解释一下activity、 intent 、intent filter、service、Broadcase、BroadcaseReceiver</p><p><strong>答案=</strong></p><p>一个activity呈现了一个用户可以操作的可视化用户界面；一个service不包含可见的用户界面，而是在后台运行，可以与一个activity绑定，通过绑定暴露出来接口并与其进行通信；一个broadcast receiver是一个接收广播消息并做出回应的component，broadcast receiver没有界面；一个intent是一个Intent对象，它保存了消息的内容。对于activity和service来说，它指定了请求的操作名称和待操作数据的URI，Intent对象可以显式的指定一个目标component。如果这样的话，android会找到这个component(基于manifest文件中的声明)并激活它。但如果一个目标不是显式指定的，android必须找到响应intent的最佳component。它是通过将Intent对象和目标的intent filter相比较来完成这一工作的；一个component的intent filter告诉android该component能处理的intent。intent filter也是在manifest文件中声明的。</p><p><br/></p><p><strong>题干=</strong></p><p>Activity生命周期？</p><p><strong>答案=</strong></p><p>onCreate() -&gt; onStart() -&gt; onResume() -&gt; onPause() -&gt; onStop() -&gt; onDetroy()</p><p>可见生命周期：从onStart()直到系统调用onStop()</p><p>前台生命周期：从onResume()直到系统调用onPause()</p><p><br/></p><p><strong>题干=</strong></p><p>请介绍下Android中常用的五种布局。</p><p><strong>答案=</strong></p><p>常用五种布局方式，分别是：FrameLayout（框架布局），LinearLayout （线性布局），AbsoluteLayout（绝对布局），RelativeLayout（相对布局），TableLayout（表格布局）。</p><p>1、FrameLayout：所有东西依次都放在左上角，会重叠，这个布局比较简单，也只能放一点比较简单的东西。</p><p>2、LinearLayout：线性布局，每一个LinearLayout里面又可分为垂直布局（android:orientation=&quot;vertical&quot;）和水平布局（android:orientation=&quot;horizontal&quot; ）。当垂直布局时，每一行就只有一个元素，多个元素依次垂直往下；水平布局时，只有一行，每一个元素依次向右排列。</p><p>3、AbsoluteLayout：绝对布局用X,Y坐标来指定元素的位置，这种布局方式也比较简单，但是在屏幕旋转时，往往会出问题，而且多个元素的时候，计算比较麻烦。</p><p>4、RelativeLayout：相对布局可以理解为某一个元素为参照物，来定位的布局方式。主要属性有：相对于某一个元素android:layout_below、&nbsp; &nbsp; &nbsp; android:layout_toLeftOf相对于父元素的地方android:layout_alignParentLeft、android:layout_alignParentRigh；</p><p>5、TableLayout：表格布局，每一个TableLayout里面有表格行TableRow，TableRow里面可以具体定义每一个元素。每一个布局都有自己适合的方式，这五个布局元素可以相互嵌套应用，做出美观的界面。</p><p><br/></p><p><strong>题干=</strong></p><p>ContentProvider和ContentResolver简介</p><p><strong>答案=</strong></p><p>当应用继承ContentProvider类，并重写该类用于提供数据和存储数据的方法，就可以向其他应用共享其数据。虽然使用其他方法也可以对外共享数据，但数据访问方式会因数据存储的方式而不同，如：采用文件方式对外共享数据，需要进行文件操作读写数据；采用sharedpreferences共享数据，需要使用sharedpreferences API读写数据。而使用ContentProvider共享数据的好处是统一了数据访问方式。</p><p><br/></p><p>Uri代表了要操作的数据，Uri主要包含了两部分信息：1.需要操作的ContentProvider ，2.对ContentProvider中的什么数据进行操作，一个Uri由以下几部分组成：</p><p>1.scheme：ContentProvider（内容提供者）的scheme已经由Android所规定为：content://…</p><p>2.主机名（或Authority）：用于唯一标识这个ContentProvider，外部调用者可以根据这个标识来找到它。</p><p>3.路径（path）：可以用来表示我们要操作的数据，路径的构建应根据业务而定。</p><p><br/></p><p>ContentResolver：当外部应用需要对ContentProvider中的数据进行添加、删除、修改和查询操作时，可以使用 ContentResolver 类来完成，要获取ContentResolver 对象，可以使用Activity提供的getContentResolver()方法。 ContentResolver使用insert、delete、update、query方法，来操作数据。</p><p><br/></p><p><strong>题干=</strong></p><p>Service的两种启动方式及生命周期</p><p><strong>答案=</strong></p><p>（1）startService()，（2）bindService()&nbsp;</p><p>bindService()方式进行绑定的生命周期走法：bindService --&gt;onCreate()--&gt;onBind()--&gt;unBind()--&gt;onDestroy()&nbsp;</p><p><br/></p><p><strong>题干=</strong></p><p>android中的动画有哪几类，它们的特点和区别是什么&nbsp;</p><p><strong>答案=</strong></p><p>帧动画：指通过指定每一帧的图片和播放时间，有序的进行播放而形成动画效果，比如想听的律动条。</p><p>补间动画：指通过指定View的初始状态、变化时间、方式，通过一系列的算法去进行图形变换，从而形成动画效果，主要有Alpha、Scale、Translate、Rotate四种效果。注意：只是在视图层实现了动画效果，并没有真正改变View的属性，比如滑动列表，改变标题栏的透明度。</p><p>属性动画：在Android3.0的时候才支持，通过不断的改变View的属性，不断的重绘而形成动画效果。相比于视图动画，View的属性是真正改变了。比如view的旋转，放大，缩小。</p><p><br/></p><p><strong>题干=</strong></p><p>请介绍下Android的数据存储方式。</p><p><strong>答案=</strong></p><p>使用SharedPreferences存储数据；文件存储数据；SQLite数据库存储数据；使用ContentProvider存储数据；网络存储数据；</p><p><br/></p><p><strong>题干=</strong></p><p>activity的启动模式有哪些？是什么含义？</p><p><strong>答案=</strong></p><p>在android里，有4种activity的启动模式，分别为：</p><p>“standard” (默认)</p><p>“singleTop”</p><p>“singleTask”</p><p>“singleInstance”</p><p><br/></p><p><strong>题干=</strong></p><p>Broadcast注册方式与区别&nbsp;</p><p><strong>答案=</strong></p><p>第一种是静态注册，也可成为常驻型广播，这种广播需要在Androidmanifest.xml中进行注册，这中方式注册的广播，不受页面生命周期的影响，即使退出了页面，也可以收到广播这种广播一般用于想开机自启动啊等等，由于这种注册的方式的广播是常驻型广播，所以会占用CPU的资源。</p><p>第二种是动态注册，而动态注册的话，是在代码中注册的，这种注册方式也叫非常驻型广播，收到生命周期的影响，退出页面后，就不会收到广播，我们通常运用在更新UI方面。这种注册方式优先级较高。最后需要解绑，否会会内存泄露。</p><p>广播是分为有序广播和无序广播。</p><p>http://www.jianshu.com/p/ea5e233d9f43&nbsp;</p><p><br/></p><p><strong>题干=</strong></p><p>AIDL的全称是什么？如何工作？能处理哪些类型的数据？</p><p><strong>答案=</strong></p><p>全称是：Android Interface Define Language</p><p><br/></p><p>在Android中, 每个应用程序都可以有自己的进程. 在写UI应用的时候, 经常要用到Service. 在不同的进程中, 怎样传递对象呢?显然, Java中不允许跨进程内存共享. 因此传递对象, 只能把对象拆分成操作系统能理解的简单形式, 以达到跨界对象访问的目的. 在J2EE中,采用RMI的方式, 可以通过序列化传递对象. 在Android中, 则采用AIDL的方式. 理论上AIDL可以传递Bundle,实际上做起来却比较麻烦。</p><p><br/></p><p>AIDL(AndRoid接口描述语言)是一种借口描述语言; 编译器可以通过aidl文件生成一段代码，通过预先定义的接口达到两个进程内部通信进程的目的. 如果需要在一个Activity中, 访问另一个Service中的某个对象, 需要先将对象转化成AIDL可识别的参数(可能是多个参数), 然后使用AIDL来传递这些参数, 在消息的接收端, 使用这些参数组装成自己需要的对象.</p><p><br/></p><p>AIDL的IPC的机制和COM或CORBA类似, 是基于接口的，但它是轻量级的。它使用代理类在客户端和实现层间传递值. 如果要使用AIDL, 需要完成2件事情: 1. 引入AIDL的相关类.; 2. 调用aidl产生的class.</p><p><br/></p><p>AIDL的创建方法:</p><p>AIDL语法很简单,可以用来声明一个带一个或多个方法的接口，也可以传递参数和返回值。 由于远程调用的需要, 这些参数和返回值并不是任何类型.下面是些AIDL支持的数据类型:</p><p>1. 不需要import声明的简单Java编程语言类型(int,boolean等)</p><p>2. String, CharSequence不需要特殊声明</p><p>3. List, Map和Parcelables类型, 这些类型内所包含的数据成员也只能是简单数据类型, String等其他比支持的类型.</p><p>(另外: 我没尝试Parcelables, 在Eclipse+ADT下编译不过, 或许以后会有所支持)</p><p><br/></p><p><strong>题干=</strong></p><p>Service和Thread的区别？</p><p><strong>答案=</strong></p><p>servie是系统的组件，它由系统进程托管（servicemanager）；它们之间的通信类似于client和server，是一种轻量级的ipc通信，这种通信的载体是binder，它是在linux层交换信息的一种ipc。而thread是由本应用程序托管。1). Thread：Thread 是程序执行的最小单元，它是分配CPU的基本单位。可以用 Thread 来执行一些异步的操作。</p><p><br/></p><p>2). Service：Service 是android的一种机制，当它运行的时候如果是Local Service，那么对应的 Service 是运行在主进程的 main 线程上的。如：onCreate，onStart 这些函数在被系统调用的时候都是在主进程的 main 线程上运行的。如果是Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。</p><p><br/></p><p>既然这样，那么我们为什么要用 Service 呢？其实这跟 android 的系统机制有关，我们先拿 Thread 来说。Thread 的运行是独立于 Activity 的，也就是说当一个 Activity 被 finish 之后，如果你没有主动停止 Thread 或者 Thread 里的 run 方法没有执行完毕的话，Thread 也会一直执行。因此这里会出现一个问题：当 Activity 被 finish 之后，你不再持有该 Thread 的引用。另一方面，你没有办法在不同的 Activity 中对同一 Thread 进行控制。&nbsp;</p><p><br/></p><p>举个例子：如果你的 Thread 需要不停地隔一段时间就要连接服务器做某种同步的话，该 Thread 需要在 Activity 没有start的时候也在运行。这个时候当你 start 一个 Activity 就没有办法在该 Activity 里面控制之前创建的 Thread。因此你便需要创建并启动一个 Service ，在 Service 里面创建、运行并控制该 Thread，这样便解决了该问题（因为任何 Activity 都可以控制同一 Service，而系统也只会创建一个对应 Service 的实例）。&nbsp;</p><p><br/></p><p>因此你可以把 Service 想象成一种消息服务，而你可以在任何有 Context 的地方调用 Context.startService、Context.stopService、Context.bindService，Context.unbindService，来控制它，你也可以在 Service 里注册 BroadcastReceiver，在其他地方通过发送 broadcast 来控制它，当然这些都是 Thread 做不到的。</p><p><br/></p><p><strong>题干=</strong></p><p>Android中进程间通信的方式，跨进程通讯</p><p><strong>答案=</strong>&nbsp;</p><p>（1）AIDL，（2）广播（BroadcastReceiver），（3）Messenger&nbsp;</p><p>intent：这种跨进程方式并不是访问内存的形式，它需要传递一个uri,比如说打电话。</p><p>contentProvider：这种形式，是使用数据共享的形式进行数据共享。</p><p>AIDL: 每一个进程都有自己的Dalvik VM实例，都有自己的一块独立的内存，都在自己的内存上存储自己的数据，执行着自己的操作，都在自己的那片狭小的空间里过完自己的一生。而aidl就类似与两个进程之间的桥梁，使得两个进程之间可以进行数据的传输，跨进程通信有多种选择，比如 BroadcastReceiver , Messenger 等，但是 BroadcastReceiver 占用的系统资源比较多，如果是频繁的跨进程通信的话显然是不可取的；Messenger 进行跨进程通信时请求队列是同步进行的，无法并发执行。</p><p><br/></p><p><strong>题干=</strong></p><p>Handler的原理</p><p><strong>答案=</strong></p><p>Android中主线程是不能进行耗时操作的，子线程是不能进行更新UI的。所以就有了handler，它的作用就是实现线程之间的通信。</p><p>handler整个流程中，主要有四个对象，handler，Message,MessageQueue,Looper。当应用创建的时候，就会在主线程中创建handler对象，</p><p>我们通过要传送的消息保存到Message中，handler通过调用sendMessage方法将Message发送到MessageQueue中，Looper对象就会不断的调用loop()方法</p><p>不断的从MessageQueue中取出Message交给handler进行处理。从而实现线程之间的通信。</p><p><br/></p><p><strong>题干=</strong></p><p>生命是ANR？</p><p><strong>答案=</strong></p><p>ANR全名Application Not Responding, 也就是&quot;应用无响应&quot;. 当操作在一段时间内系统无法处理时, 系统层面会弹出上图那样的ANR对话框.</p><p>产生原因：</p><p>(1)5s内无法响应用户输入事件(例如键盘输入, 触摸屏幕等).</p><p>(2)BroadcastReceiver在10s内无法结束</p><p>(3)Service 20s内无法结束（低概率）</p><p><br/></p><p><strong>题干=</strong></p><p>什么是Fragment？介绍一下</p><p><strong>答案=</strong></p><p>Android 3.0中引入fragments 的概念，译为:碎片、片段。其目的是为了解决不同屏幕分辩率的动态和灵活UI设计。平板电脑的设计使得其有更多的空间来放更多的UI组件，而多出来的空间存放UI使其会产生更多的交互，从而诞生了fragments 。</p><p>fragments 的设计不需要你来亲自管理view hierarchy 的复杂变化，通过将Activity 的布局分散到frament 中，可以在运行时修改activity 的外观，并且由activity 管理的back stack 中保存些变化。当一个片段指定了自身的布局时，它能和其他片段配置成不同的组合，在活动中为不同的屏幕尺寸修改布局配置（小屏幕可能每次显示一个片段，而大屏幕则可以显示两个或更多）。</p><p>Fragment不能独立存在，必须嵌入到Activity中</p><p>Fragment具有自己的生命周期，接收它自己的事件，并可以在Activity运行时被添加或删除</p><p>Fragment的生命周期直接受所在的Activity的影响。如：当Activity暂停时，它拥有的所有Fragment们都暂停</p><p>生命周期：</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>onAttach方法</p><p>Fragment和Activity建立关联的时候调用（获得activity的传递的值）</p></li><li><p>onCreateView方法</p><p>为Fragment创建视图（加载布局）时调用（给当前的fragment绘制UI布局，可以使用线程更新UI）</p></li><li><p>onActivityCreated方法</p><p>当Activity中的onCreate方法执行完后调用（表示activity执行oncreate方法完成了的时候会调用此方法）</p></li><li><p>onDestroyView方法</p><p>Fragment中的布局被移除时调用（表示fragment销毁相关联的UI布局）</p></li><li><p>onDetach方法</p><p>Fragment和Activity解除关联的时候调用（脱离activity）</p></li></ul><p>参见：<a href="https://www.cnblogs.com/WangQuanLong/p/5826098.html">https://www.cnblogs.com/WangQuanLong/p/5826098.html</a></p><p><br/></p><p><strong>题干=</strong></p><p>handler机制的原理</p><p><strong>答案=</strong></p><p>andriod提供了 Handler 和 Looper 来满足线程间的通信。Handler 先进先出原则。Looper类用来管理特定线程内对象之间的消息交换(Message Exchange)。</p><p>1) Looper: 一个线程可以产生一个Looper对象，由它来管理此线程里的Message Queue(消息队列)。</p><p>2) Handler: 你可以构造Handler对象来与Looper沟通，以便push新消息到Message Queue里;或者接收Looper从Message Queue取出)所送来的消息。</p><p>3) Message Queue(消息队列):用来存放线程放入的消息。</p><p>4) 线程：UI thread 通常就是main thread，而Android启动程序时会替它建立一个Message Queue</p><p><br/></p><p><strong>题干=</strong></p><p>AsyncTask的工作原理</p><p><strong>答案=</strong></p><p>AsyncTask是Android本身提供的一种轻量级的异步任务类。它可以在线程池中执行后台任务，然后把执行的进度和最终的结果传递给主线程更新UI。实际上，AsyncTask内部是封装了Thread和Handler。虽然AsyncTask很方便的执行后台任务，以及在主线程上更新UI，但是，AsyncTask并不合适进行特别耗时的后台操作，对于特别耗时的任务，个人还是建议使用线程池。</p><p><br/></p>
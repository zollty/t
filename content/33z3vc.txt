<p><strong>题干=</strong><br/></p><p>1、Java的线程池框架Executor包含哪些核心的类，分别介绍一下？</p><p>2、线程池的实现类ThreadPoolExecutor中的两个属性corePoolSize、maximumPoolSize的含义和作用是什么？</p><p>3、结合线程池的核心线程数、线程队列、超时时间等参数，说明一下线程池的工作原理和过程。</p><p><strong>答案=</strong></p><p>包括：Executor，Executors，ExecutorService，ThreadPoolExecutor ，Callable和Future、FutureTask等。</p><p><strong>Executor</strong>: 所有线程池的接口,只有一个execute(Runnable r)方法。</p><p><strong>ExecutorService</strong>: 增加Executor的行为，是Executor实现类的最直接接口。</p><p><strong>Executors</strong>： 提供了一系列工厂方法用于创先线程池，返回的线程池都实现了ExecutorService 接口。</p><p><strong>ThreadPoolExecutor</strong>：线程池的具体实现类，继承于AbstractExecutorService，一般用的各种线程池都是基于这个类实现的。</p><p>构造方法如下:</p><pre class="brush:java;toolbar:false">ThreadPoolExecutor(int&nbsp;corePoolSize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;maximumPoolSize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;keepAliveTime,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TimeUnit&nbsp;unit,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlockingQueue&lt;Runnable&gt;&nbsp;workQueue,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ThreadFactory&nbsp;threadFactory,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RejectedExecutionHandler&nbsp;handler)</pre><p>corePoolSize：核心线程数，默认情况下核心线程会一直存活，即使处于闲置状态也不会受存keepAliveTime限制。除非将allowCoreThreadTimeOut设置为true。</p><p><br/></p><p>maximumPoolSize：线程池所能容纳的最大线程数。超过这个数的线程将被阻塞。当任务队列为没有设置大小的LinkedBlockingDeque时，这个值无效。</p><p><br/></p><p>keepAliveTime：非核心线程的闲置超时时间，超过这个时间就会被回收。</p><p><br/></p><p>workQueue：线程池中的任务队列。常用的有三种队列：SynchronousQueue、LinkedBlockingDeque、ArrayBlockingQueue。</p><p><br/></p><p>RejectedExecutionHandler：是一个接口，当线程池中的资源已经全部使用，添加新线程被拒绝时，会调用RejectedExecutionHandler的rejectedExecution方法。常用拒绝策略如下：</p><pre class="brush:java;toolbar:false">//丢弃任务并抛出RejectedExecutionException异常。
ThreadPoolExecutor.AbortPolicy

//也是丢弃任务，但是不抛出异常。
ThreadPoolExecutor.DiscardPolicy&nbsp;

//丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
ThreadPoolExecutor.DiscardOldestPolicy&nbsp;

//由调用线程处理该任务
ThreadPoolExecutor.CallerRunsPolicy</pre><p>原理：在 ThreadPoolExecutor 类中，还有一个内部类 Worker 类，它主要是用来维护运行任务的线程中断状态，它实现了AbstractQueuedSynchronizer和Runnable，表示它也是一个线程。</p><pre class="brush:java;toolbar:false">private&nbsp;final&nbsp;class&nbsp;Worker&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;extends&nbsp;AbstractQueuedSynchronizer&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;implements&nbsp;Runnable&nbsp;{...}</pre><p>具体参见 队列同步器 AbstractQueuedSynchronizer（AQS）相关资料。</p><p><br/></p><p><strong>ScheduledExecutorService</strong>（及其实现类<strong>ScheduledThreadPoolExecutor</strong>）</p><p>用法示例：<br/></p><pre class="brush:java;toolbar:false">ScheduledExecutorService&nbsp;scheduledExecutorService&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Executors.newScheduledThreadPool(5);

ScheduledFuture&nbsp;scheduledFuture&nbsp;=
&nbsp;&nbsp;&nbsp;&nbsp;scheduledExecutorService.schedule(new&nbsp;Callable()&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Object&nbsp;call()&nbsp;throws&nbsp;Exception&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Executed!&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&quot;Called!&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;5,
&nbsp;&nbsp;&nbsp;&nbsp;TimeUnit.SECONDS);</pre><p>ScheduledExecutorService 核心方法</p><pre class="brush:java;toolbar:false">schedule&nbsp;(Callable&nbsp;task,&nbsp;long&nbsp;delay)
schedule&nbsp;(Runnable&nbsp;task,&nbsp;long&nbsp;delay)
scheduleAtFixedRate&nbsp;(Runnable,&nbsp;long&nbsp;initialDelay,&nbsp;long&nbsp;period)
scheduleWithFixedDelay&nbsp;(Runnable,&nbsp;long&nbsp;initialDelay,&nbsp;long&nbsp;period)</pre><p>ScheduledThreadPoolExecutor原理：其线程池队列为DelayedWorkQueue，它是对DelayQueue的优化：</p><pre class="brush:java;toolbar:false">public&nbsp;ScheduledThreadPoolExecutor(int&nbsp;corePoolSize)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;super(corePoolSize,&nbsp;Integer.MAX_VALUE,&nbsp;0,&nbsp;TimeUnit.NANOSECONDS,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;DelayedWorkQueue());
}</pre><p>具体参见DelayQueue相关的资料。</p><p><br/></p><p><strong>Future&lt;V&gt;</strong>接口和<strong>FutureTask</strong>类</p><p>Future 是一个接口，代表可以取消的任务，并可以获得任务的执行结果。</p><p>FutureTask 是基本的实现了Future和Runnable接口。</p><p>Future 配合 ExecutorService.submit方法使用：</p><pre class="brush:java;toolbar:false">&lt;T&gt;&nbsp;Future&lt;T&gt;&nbsp;submit(Callable&lt;T&gt;&nbsp;task);</pre><p>方法解析：</p><p><strong>V get()</strong> ：获取异步执行的结果，如果没有结果可用，此方法会阻塞直到异步计算完成。</p><p><strong>V get(Long timeout) </strong>：获取异步执行结果，如果没有结果可用，此方法会阻塞，但是会有时间限制，如果阻塞时间超过设定的timeout时间，该方法将抛出异常。</p><p><strong>boolean isDone() </strong>：判断如果任务执行结束，无论是正常结束或是中途取消还是发生异常，都返回true。</p><p><strong>boolean isCanceller()</strong> ：判断如果任务完成前被取消，则返回true。</p><p><strong>boolean cancel(boolean mayInterruptRunning) </strong>：如果任务还没开始，执行cancel(...)方法将返回false；如果任务已经启动，执行cancel(true)方法将以中断执行此任务线程的方式来试图停止任务，如果停止成功，返回true；当任务已经启动，执行cancel(false)方法将不会对正在执行的任务线程产生影响(让线程正常执行到完成)，此时返回false；当任务已经完成，执行cancel(...)方法将返回false。</p><p><br/></p><p>FutureTask = Future + Runnable，示例如下：</p><pre class="brush:java;toolbar:false">CallableDemo&nbsp;calTask&nbsp;=&nbsp;new&nbsp;CallableDemo();
FutureTask&lt;Integer&gt;&nbsp;futureTask&nbsp;=&nbsp;new&nbsp;FutureTask&lt;&gt;(calTask);
es.submit(futureTask);

CallableDemo&nbsp;calTask&nbsp;=&nbsp;new&nbsp;CallableDemo();
Future&lt;Integer&gt;&nbsp;future&nbsp;=&nbsp;es.submit(calTask);</pre><p>原理：FutureTask也是基于AQS来构建的，即：</p><pre class="brush:java;toolbar:false">private&nbsp;final&nbsp;class&nbsp;Sync&nbsp;extends&nbsp;AbstractQueuedSynchronizer&nbsp;{...}</pre><p>具体参见AQS。<br/></p><p><br/></p><p><strong>线程池的工作过程如下</strong>：</p><p>1、线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</p><p>2、当调用 execute() 方法添加一个任务时，线程池会做如下判断：</p><ol class="custom_num1 list-paddingleft-1"><li class="list-num-2-1 list-num1-paddingleft-1"><p>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</p></li><li class="list-num-2-2 list-num1-paddingleft-1"><p>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</p></li><li class="list-num-2-3 list-num1-paddingleft-1"><p>如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</p></li><li class="list-num-2-4 list-num1-paddingleft-1"><p>如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常RejectExecutionException。</p></li></ol><p>3、当一个线程完成任务时，它会从队列中取下一个任务来执行。</p><p>4、当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</p><p><br/></p><p><strong>题干=</strong><br/></p><p>有如下线程池定义：ThreadPoolExecutor executor = new ThreadPoolExecutor(3, 4, 5, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;Runnable&gt;(2));</p><p>依次添加6个耗时2秒的任务并执行（execute），其执行效果如何（描述一下这6个任务在线程池内的执行过程），8秒钟后线程池的内部状态如何？</p><p>如果把队列的参数改为1，效果又如何？</p><p><strong>答案=</strong></p><p>线程池首先为前三个任务开启三个核心线程1，2，3，然后第四个任务和第五个任务不会立即执行，会加入到Linked阻塞队列中，第六个任务因为队列满了但是maximumPoolSize没有满，会直接创建一个非核心线程4。这是一共有四个线程运行。8秒后，非核心线程受超时时间（5秒）影响回收了，因此线程池只剩3个核心线程了。</p><p><br/></p><p>如果队列参数改为1，前面5个执行情况一样，但是会直接出错在第6个execute方法上。因为核心线程是3个，当加入第四个任务的时候，就把第四个放在队列中。但是加入第五个任务时，因为队列满了，就创建新非核心线程执行，创建了线程4。当加入第六个线程时，也会尝试创建线程，但是因为已经达到了线程池最大线程数，所以直接抛异常了。</p><p>参考文章：<a href="https://blog.csdn.net/qq_25806863/article/details/71126867">https://blog.csdn.net/qq_25806863/article/details/71126867</a> </p><p><br/></p><p><strong>题干=</strong><br/></p><p>有如下线程池定义：ThreadPoolExecutor executor = new ThreadPoolExecutor(3, 4, 5, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;Runnable&gt;());</p><p>依次添加6个耗时2秒的任务并执行（execute），其执行效果如何（描述一下这6个任务在线程池内的执行过程），8秒钟后线程池的内部状态如何？</p><p>如果把队列改为SynchronousQueue，效果又如何？</p><p><strong>答案=</strong></p><p>线程池首先为前三个任务开启三个核心线程1，2，3，然后第四个任务、第五个任务和第六个任务不会立即执行，会加入到Linked阻塞队列中，等2秒钟后，前三个任务执行完后，后3个任务复用核心线程执行。8秒后，3个核心线程不会回收、仍然存在。注意，此处的参数maximumPoolSize=4不起作用，因为总线程数始终为3，不会超过4，无论有多少任务添加进来，都会添加到阻塞队列中。</p><p><br/></p><p>如果队列改为SynchronousQueue，前面3个任务执行情况一样，但是后面3个任务会开启非核心线程去立即执行，大约2秒后 ，所有6个任务都执行完成。8秒后，只剩3个核心线程。因为SynchronousQueue跟Executors.newCachedThreadPool()很像，对于新来的任务，它会立即执行、不会阻塞起来。SynchronousQueue的作用是把所有新建的线程，用完后都保留下来供后来的任务复用，或者直到线程超过idle闲置时间被清楚。具体参见&nbsp;Executors.newCachedThreadPool()相关的说明。</p><p><br/></p><p>参考文章：<a href="https://blog.csdn.net/qq_25806863/article/details/71126867">https://blog.csdn.net/qq_25806863/article/details/71126867</a> </p><p><br/></p><p><strong>题干=</strong></p><p>线程池有哪几种默认类型和创建方式？</p><p><strong>答案=</strong></p><p>常用工具类Executors的静态方法来创建，一共有4种默认策略：</p><pre class="brush:java;toolbar:false">new&nbsp;SingleThreadExecutor
new&nbsp;FixedThreadPool
new&nbsp;CachedThreadPool
new&nbsp;ScheduledThreadPool</pre><p><br/></p><p><strong>SingleThreadExecutor</strong>：单个后台线程 (其缓冲队列是无界的)</p><pre class="brush:java;toolbar:false">public&nbsp;static&nbsp;ExecutorService&nbsp;newSingleThreadExecutor()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;FinalizableDelegatedExecutorService&nbsp;(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;ThreadPoolExecutor(1,&nbsp;1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0L,&nbsp;TimeUnit.MILLISECONDS,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;LinkedBlockingQueue&lt;Runnable&gt;()));&nbsp;&nbsp;&nbsp;
}</pre><p>创建一个单线程的线程池。这个线程池只有一个核心线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p><p><br/></p><p><strong>FixedThreadPool</strong>：只有核心线程的线程池,大小固定 (其缓冲队列是无界的) 。</p><pre class="brush:java;toolbar:false">public&nbsp;static&nbsp;ExecutorService&nbsp;newFixedThreadPool(int&nbsp;nThreads)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;ThreadPoolExecutor(nThreads,&nbsp;nThreads,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0L,&nbsp;TimeUnit.MILLISECONDS,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;LinkedBlockingQueue&lt;Runnable&gt;());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</pre><p>创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p><p><br/></p><p><strong>CachedThreadPool</strong>：无界线程池，可以进行自动线程回收。</p><pre class="brush:java;toolbar:false">public&nbsp;static&nbsp;ExecutorService&nbsp;newCachedThreadPool()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;ThreadPoolExecutor(0,Integer.MAX_VALUE,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;60L,&nbsp;TimeUnit.SECONDS,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;SynchronousQueue&lt;Runnable&gt;());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</pre><p>如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。SynchronousQueue是一个是缓冲区为1的阻塞队列。</p><p><br/></p><p><strong>ScheduledThreadPool</strong>：核心线程池固定，大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p><pre class="brush:java;toolbar:false">public&nbsp;static&nbsp;ExecutorService&nbsp;newScheduledThreadPool(int&nbsp;corePoolSize)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;ScheduledThreadPool(corePoolSize,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer.MAX_VALUE,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DEFAULT_KEEPALIVE_MILLIS,&nbsp;MILLISECONDS,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;DelayedWorkQueue());&nbsp;&nbsp;&nbsp;&nbsp;
}</pre><p>创建一个周期性执行任务的线程池。如果闲置,非核心线程池会在DEFAULT_KEEPALIVEMILLIS时间内回收。</p><p><br/></p><p><strong>题干=</strong></p><p>线程池有哪几种提交任务的方式？</p><p><strong>答案=</strong></p><p>线程池最常用的提交任务的方法有两种：</p><p><br/></p><p>execute:</p><pre class="brush:java;toolbar:false">ExecutorService.execute(Runnable&nbsp;runable)；</pre><p>submit:</p><pre class="brush:java;toolbar:false">FutureTask&nbsp;task&nbsp;=&nbsp;ExecutorService.submit(Runnable&nbsp;runnable);
FutureTask&lt;T&gt;&nbsp;task&nbsp;=&nbsp;ExecutorService.submit(Runnable&nbsp;runnable,T&nbsp;Result);
FutureTask&lt;T&gt;&nbsp;task&nbsp;=&nbsp;ExecutorService.submit(Callable&lt;T&gt;&nbsp;callable);</pre><p>submit(Callable callable)的实现，submit(Runnable runnable)同理。</p><pre class="brush:java;toolbar:false">public&nbsp;&lt;T&gt;&nbsp;Future&lt;T&gt;&nbsp;submit(Callable&lt;T&gt;&nbsp;task)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(task&nbsp;==&nbsp;null)&nbsp;throw&nbsp;new&nbsp;NullPointerException();
&nbsp;&nbsp;&nbsp;&nbsp;FutureTask&lt;T&gt;&nbsp;ftask&nbsp;=&nbsp;newTaskFor(task);
&nbsp;&nbsp;&nbsp;&nbsp;execute(ftask);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ftask;
}</pre><p>可以看出submit开启的是有返回结果的任务，会返回一个FutureTask对象，这样就能通过get()方法得到结果。submit最终调用的也是execute(Runnable runable)，submit只是将Callable对象或Runnable封装成一个FutureTask对象，因为FutureTask是个Runnable，所以可以在execute中执行。</p><p><br/></p>